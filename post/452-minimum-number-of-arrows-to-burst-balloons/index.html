<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>452. Minimum Number of Arrows to Burst Balloons | 10K&#39;s</title>
<link rel="shortcut icon" href="https://10kshuaizhang.github.io/favicon.ico?v=1687157630552">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://10kshuaizhang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="452. Minimum Number of Arrows to Burst Balloons | 10K&#39;s - Atom Feed" href="https://10kshuaizhang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-L6PETZ11Z8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-L6PETZ11Z8');
</script>


    <meta name="description" content="Problem
This problem looks complicated to describe, so look at it more closely. We have a bunch of balloons, ğŸˆ staggere..." />
    <meta name="keywords" content="Greedy algorithm,LeetCode" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://10kshuaizhang.github.io">
  <img class="avatar" src="https://10kshuaizhang.github.io/images/avatar.png?v=1687157630552" alt="">
  </a>
  <h1 class="site-title">
    10K&#39;s
  </h1>
  <p class="site-description">
    Shortcuts are the farthest path, so you must write and think honestly, which is the basic requirement for progress.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu">
          Archive
        </a>
      
    
      
        <a href="/post/about" class="menu">
          About
        </a>
      
    
      
        <a href="/tags" class="menu">
          Tags
        </a>
      
    
      
        <a href="/post/books" class="menu">
          Books
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/10kshuaizhang" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/jason278642682" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              452. Minimum Number of Arrows to Burst Balloons
            </h2>
            <div class="post-info">
              <span>
                2023-03-21
              </span>
              <span>
                6 min read
              </span>
              
                <a href="https://10kshuaizhang.github.io/tag/xldsVr9iS/" class="post-tag">
                  # Greedy algorithm
                </a>
              
                <a href="https://10kshuaizhang.github.io/tag/4zkg5-iEk/" class="post-tag">
                  # LeetCode
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h2 id="problem">Problem</h2>
<p>This problem looks complicated to describe, so look at it more closely. We have a bunch of balloons, ğŸˆ staggered in front of you, you shoot one arrow at a time, when the balloons are not overlapping, one arrow can only shoot through one balloon; when the balloons are overlapping, one arrow can shoot through them all. Ask how many arrows are needed to shoot through all the balloons. A diagram of this topic is clear at a glance.</p>
<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202303211111814.png" alt="image-20230321111119694" style=" zoom:50%;" />
<h2 id="algorithms">Algorithms</h2>
<p>Seeing the most value can be considered using greedy thinking.</p>
<blockquote>
<p>Dynamic programming is actually also an idea to consider when you see the most value. Of course there are some differences between the two, and the final decision is whether to use greedy thinking or dynamic programming.</p>
<p>Also, we are talking about &quot;ideas&quot; here, not algorithms. Because this is an idea, a direction, not a specific algorithm.</p>
</blockquote>
<p>This topic has the most value, use greedy thinking to try to consider. First find the local optimal solution, then iterate forward until the end.</p>
<p>As we can see from the figure above, we can iterate through the balloons from left to right (sorting first), and then when a balloon does not overlap with the previous balloon we can move to the new balloon and ignore the previous balloon (the previous result has been saved).</p>
<p>Here we first need to sort the balloons (according to their end position or right border), at this time will need to consume an arrow; then continue to look behind the balloon, if the balloon behind the overlap with the previous one, that is, the left border of the back is smaller than the current right border, then they can be shot by the same arrow, the cycle continues; when encountered no overlap balloon. That is, the left boundary of the balloon is greater than the current right boundary, at this time an arrow has not been able to pierce them, the new balloon needs another arrow, the result increases one, and at this time the new right boundary is the new right boundary of this balloon, we have to continue to look at the left boundary of the balloon behind him prevail.</p>
<h2 id="code">Code</h2>
<pre><code class="language-java">class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points == null || points.length == 0 || points[0] == null || points[0].length == 0) {
            return Integer.MAX_VALUE;
        }
        
        int res = 1;
        Arrays.sort(points, (a, b) -&gt; {
            if (a[1] == b[1]) return 0;
            if (a[1] &lt; b[1]) return -1;
            return 1;
        });
        int end = points[0][1];
        
        for (int i = 1; i &lt; points.length; i++) {
            if (points[i][0] &gt; end) {
                res++;
                end = points[i][1];
            } 
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>The code before this topic, can't pass the test anymore, because before for array sorting use <code>Arrays.sort(points, (a, b) -&gt; (a[1] - b[1]));</code> for larger numbers, such as <code>[[-2147483646, -2147483645], [2147483646, 2147483647]]</code>, the result of their operations in anonymous functions may cause overflow, which in turn may affect the correctness of the result.</p>
</blockquote>
<hr>
<h2 id="é—®é¢˜">é—®é¢˜</h2>
<p>è¿™ä¸ªé—®é¢˜çœ‹èµ·æ¥æè¿°çš„å¤æ‚ï¼Œè¦å¤šä»”ç»†çœ‹ä¸€ä¸‹ã€‚å°±æ˜¯æˆ‘ä»¬æœ‰ä¸€å †æ°”çƒï¼ŒğŸˆäº¤é”™çš„æ’åˆ—åœ¨ä½ çš„é¢å‰ï¼Œä½ æ¯æ¬¡å°„ä¸€æ”¯ç®­ï¼Œå½“æ°”çƒæ²¡æœ‰é‡å ï¼Œä¸€æ”¯ç®­åªèƒ½å°„ç©¿ä¸€ä¸ªæ°”çƒï¼›å½“æ°”çƒé‡å ï¼Œä¸€æ”¯ç®­å¯ä»¥æŠŠä»–ä»¬éƒ½å°„ç©¿ã€‚é—®æœ€å°‘éœ€è¦å¤šå°‘æ”¯ç®­å°„ç©¿å…¨éƒ¨æ°”çƒã€‚è¿™ä¸ªé¢˜ç›®ç”»ä¸ªå›¾ä¸€ç›®äº†ç„¶ï¼š</p>
<img src="https://raw.githubusercontent.com/10kshuaizhang/note-images/main/202303211111814.png" alt="image-20230321111119694" style="zoom:50%;" />
<h2 id="ç®—æ³•">ç®—æ³•</h2>
<p>çœ‹åˆ°æ±‚æœ€å€¼å¯ä»¥è€ƒè™‘ä½¿ç”¨è´ªå¿ƒæ€æƒ³ã€‚</p>
<blockquote>
<p>åŠ¨æ€è§„åˆ’å…¶å®ä¹Ÿæ˜¯çœ‹åˆ°æœ€å€¼çš„æ—¶å€™å¯ä»¥è€ƒè™‘çš„ä¸€ç§æ€è·¯ã€‚å½“ç„¶è¿™ä¸¤è€…å­˜åœ¨ä¸€äº›åŒºåˆ«ï¼Œæœ€ç»ˆä»¥å†³å®šä½¿ç”¨è´ªå¿ƒæ€æƒ³è¿˜æ˜¯åŠ¨æ€è§„åˆ’æ€æƒ³ã€‚</p>
<p>å¦å¤–è¿™é‡Œè¯´çš„æ˜¯â€œæ€æƒ³â€è€Œéç®—æ³•ã€‚å› ä¸ºè¿™æ˜¯ä¸€ç§æ€è·¯ï¼ŒæŒ‡å¯¼æ–¹å‘ï¼Œè€Œéä¸€ä¸ªå…·ä½“çš„ç®—æ³•ã€‚</p>
</blockquote>
<p>è¿™ä¸ªé¢˜ç›®æœ‰æ±‚æœ€å€¼ï¼Œä½¿ç”¨è´ªå¿ƒæ€è·¯å»å°è¯•è€ƒè™‘ä¸€ä¸‹ã€‚å…ˆæ±‚å±€éƒ¨æœ€ä¼˜è§£ï¼Œç„¶åå‘å‰è¿­ä»£ï¼Œç›´åˆ°æœ€åã€‚</p>
<p>æˆ‘ä»¬æ ¹æ®ä¸Šå›¾å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥ä»å·¦åˆ°å³å»éå†è¿™äº›æ°”çƒï¼ˆå…ˆæ’åºï¼‰ï¼Œç„¶åå½“ä¸€ä¸ªæ°”çƒä¸å‰ä¸€ä¸ªæ°”çƒä¸é‡å çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥ç§»åŠ¨åˆ°æ–°çš„çš„æ°”çƒï¼Œè€Œä¸ç”¨ç®¡ä¹‹å‰çš„æ°”çƒäº†ï¼ˆä¹‹å‰çš„ç»“æœå·²ç»ä¿å­˜ï¼‰ã€‚</p>
<p>è¿™é‡Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å°†æ°”çƒä»¬æ’åºï¼ˆæŒ‰ç…§ä»–ä»¬çš„ç»“æŸä½ç½®æˆ–è€…æ˜¯å³è¾¹ç•Œï¼‰ï¼Œæ­¤æ—¶å°†éœ€è¦æ¶ˆè€—ä¸€æ”¯ç®­ï¼›ç„¶åç»§ç»­çœ‹åé¢çš„æ°”çƒï¼Œå¦‚æœåé¢çš„æ°”çƒä¸å‰é¢çš„é‡å ï¼Œä¹Ÿå³åé¢çš„å·¦è¾¹ç•Œå°äºå½“å‰çš„å³è¾¹ç•Œï¼Œé‚£ä¹ˆä»–ä»¬å¯ä»¥è¢«åŒä¸€æ”¯ç®­å°„ç©¿ï¼Œå¾ªç¯ç»§ç»­ï¼›å½“é‡åˆ°æ²¡é‡å çš„æ°”çƒã€‚å³æ°”çƒçš„å·¦è¾¹ç•Œå¤§äºå½“å‰çš„å³è¾¹ç•Œï¼Œæ­¤æ—¶ä¸€æ”¯ç®­å·²ç»ä¸èƒ½æˆ³ç©¿ä»–ä»¬äº†ï¼Œæ–°çš„æ°”çƒéœ€è¦å¦ä¸€æ”¯ç®­ï¼Œç»“æœå¢åŠ ä¸€ä¸ªï¼Œå¹¶ä¸”æ­¤æ—¶æ–°çš„å³è¾¹ç•Œæ˜¯æ–°çš„è¿™ä¸ªæ°”çƒçš„å³è¾¹ç•Œï¼Œæˆ‘ä»¬è¦ä¾ä»–ä¸ºå‡†ç»§ç»­çœ‹åé¢çš„æ°”çƒçš„å·¦è¾¹ç•Œäº†ã€‚</p>
<h2 id="ä»£ç ">ä»£ç </h2>
<pre><code class="language-java">class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points == null || points.length == 0 || points[0] == null || points[0].length == 0) {
            return Integer.MAX_VALUE;
        }
        
        int res = 1;
        Arrays.sort(points, (a, b) -&gt; {
            if (a[1] == b[1]) return 0;
            if (a[1] &lt; b[1]) return -1;
            return 1;
        });
        int end = points[0][1];
        
        for (int i = 1; i &lt; points.length; i++) {
            if (points[i][0] &gt; end) {
                res++;
                end = points[i][1];
            } 
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>è¿™ä¸ªé¢˜ç›®ä¹‹å‰çš„ä»£ç ï¼Œæ— æ³•é€šè¿‡æµ‹è¯•äº†ï¼Œå› ä¸ºä¹‹å‰å¯¹äºæ•°ç»„æ’åºä½¿ç”¨çš„æ˜¯ <code>Arrays.sort(points, (a, b) -&gt; (a[1] - b[1]));</code> å¯¹äºè¾ƒå¤§çš„æ•°å­—ï¼Œä¾‹å¦‚<code>[[-2147483646, -2147483645], [2147483646, 2147483647]]</code>, ä»–ä»¬åœ¨åŒ¿åå‡½æ•°ä¸­çš„è¿ç®—ç»“æœï¼Œå¯èƒ½ä¼šé€ æˆoverflowï¼Œè¿›è€Œä¼šå½±å“ç»“æœçš„æ­£ç¡®æ€§ã€‚</p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#algorithms">Algorithms</a></li>
<li><a href="#code">Code</a></li>
<li><a href="#%E9%97%AE%E9%A2%98">é—®é¢˜</a></li>
<li><a href="#%E7%AE%97%E6%B3%95">ç®—æ³•</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">ä»£ç </a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">ä¸‹ä¸€ç¯‡</div>
            <a href="https://10kshuaizhang.github.io/post/a-quick-note-of-segment-tree/">
              <h3 class="post-title">
                A Quick Note of Segment Tree
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '3f6a89270d2a0e51772d',
    clientSecret: '58f2d7ec868483233a31553fa6235f2efd1df763',
    repo: '10kshuaizhang.github.io',
    owner: '10kshuaizhang',
    admin: ['10kshuaizhang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  
  <a class="rss" href="https://10kshuaizhang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
