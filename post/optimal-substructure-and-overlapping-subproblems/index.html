<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Optimal substructure &amp; Overlapping subproblems | 10K&#39;s</title>
<link rel="shortcut icon" href="https://10kshuaizhang.github.io/favicon.ico?v=1687157630552">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://10kshuaizhang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Optimal substructure &amp; Overlapping subproblems | 10K&#39;s - Atom Feed" href="https://10kshuaizhang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-L6PETZ11Z8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-L6PETZ11Z8');
</script>


    <meta name="description" content="最近在做题过程中，对于一些概念变得模糊了，导致其实有时候拿不准是否该使用动态规划思路去解题，以及其中的一些解题思想。
结合自己之前的笔记，又在网上看到了一个文章，觉得不错转载过来分享和记录。动态规划之武林秘籍


动态规划算法与分治法类似，..." />
    <meta name="keywords" content="Dynamic Programming" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://10kshuaizhang.github.io">
  <img class="avatar" src="https://10kshuaizhang.github.io/images/avatar.png?v=1687157630552" alt="">
  </a>
  <h1 class="site-title">
    10K&#39;s
  </h1>
  <p class="site-description">
    Shortcuts are the farthest path, so you must write and think honestly, which is the basic requirement for progress.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu">
          Archive
        </a>
      
    
      
        <a href="/post/about" class="menu">
          About
        </a>
      
    
      
        <a href="/tags" class="menu">
          Tags
        </a>
      
    
      
        <a href="/post/books" class="menu">
          Books
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/10kshuaizhang" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/jason278642682" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Optimal substructure &amp; Overlapping subproblems
            </h2>
            <div class="post-info">
              <span>
                2023-03-05
              </span>
              <span>
                4 min read
              </span>
              
                <a href="https://10kshuaizhang.github.io/tag/8XHIFnHCE/" class="post-tag">
                  # Dynamic Programming
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>最近在做题过程中，对于一些概念变得模糊了，导致其实有时候拿不准是否该使用动态规划思路去解题，以及其中的一些解题思想。</p>
<p>结合自己之前的笔记，又在网上看到了一个文章，觉得不错转载过来分享和记录。<a href="https://www.cxyxiaowu.com/15903.html">动态规划之武林秘籍</a></p>
<ol>
<li>
<p>动态规划算法与分治法类似，其基本思想就是将待求解问题分解成若干子问题，<u>先求解子问题</u>，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合动态规划法求解的问题，<u>经分解得到的子问题往往不是相互独立的</u>。</p>
</li>
<li>
<p>最优子结构: <strong>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质</strong></p>
</li>
<li>
<p>重叠子问题:  在用递归算法自顶向下解决一个问题时，每次产生的子问题并不总是新问题，<strong>有些子问题被反复计算多次</strong>。</p>
</li>
<li>
<p>何时考虑动态规划</p>
<p>一般情况下，需要求最优解的问题（最短路径问题，最长公共子序列，最大字段和等等，出现 <strong>最</strong> 字你就留意），在一定条件下对排列进行计数的计数问题（丑数问题）或某些概率问题都可以考虑用动态规划来解决。</p>
<p>所有的动态规划问题都满足重叠子问题性质，大多数经典的动态规划问题还满足最优子结构性质，当我们从一个给定的问题中发现了这些特性，就可以确定其可以用动态规划解决。</p>
</li>
</ol>
<hr>
<p>Recently, in the process of doing problems, some concepts have become blurred, resulting in the fact that sometimes it is not possible to use dynamic planning ideas to solve the problem, as well as some of the ideas to solve the problem.</p>
<p>I think it's a good idea to share and record this article with my previous notes. <a href="https://www.cxyxiaowu.com/15903.html">Dynamic planning of the martial arts secret</a></p>
<ol>
<li>
<p>The dynamic programming algorithm is similar to the partitioning method. The basic idea is to decompose the problem to be solved into several subproblems, <u>solve the subproblems first</u>, and then get the solution of the original problem from the solution of these subproblems. Unlike the partitioning method, problems suitable for dynamic programming are <u>often not mutually independent</u> of the subproblems obtained by the decomposition.</p>
</li>
<li>
<p>Optimal substructure: <strong>When the optimal solution of a problem contains the optimal solutions of its subproblems, the problem is said to have the property of optimal substructure</strong>.</p>
</li>
<li>
<p>Overlapping subproblems: When solving a problem top-down with a recursive algorithm, each resulting subproblem is not always a new problem; <strong>some subproblems are computed multiple times</strong>.</p>
</li>
<li>
<p>When to consider dynamic programming</p>
<p>In general, problems that require optimal solutions (shortest path problems, longest common subsequence, maximal field sums, etc., look for <strong>most</strong> words when they appear), counting problems that count permutations under certain conditions (ugly number problems), or certain probability problems can be considered for dynamic programming.</p>
<p>All dynamic programming problems satisfy the overlapping subproblem property, and most classical dynamic programming problems also satisfy the optimal substructure property. When we find these properties from a given problem, we can determine that it can be solved by dynamic programming.</p>
</li>
</ol>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://10kshuaizhang.github.io/post/221-maximal-square/">
              <h3 class="post-title">
                221. Maximal Square
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '3f6a89270d2a0e51772d',
    clientSecret: '58f2d7ec868483233a31553fa6235f2efd1df763',
    repo: '10kshuaizhang.github.io',
    owner: '10kshuaizhang',
    admin: ['10kshuaizhang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  
  <a class="rss" href="https://10kshuaizhang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
