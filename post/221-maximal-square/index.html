<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>221. Maximal Square | 10K&#39;s</title>
<link rel="shortcut icon" href="https://10kshuaizhang.github.io/favicon.ico?v=1687157630552">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://10kshuaizhang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="221. Maximal Square | 10K&#39;s - Atom Feed" href="https://10kshuaizhang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-L6PETZ11Z8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-L6PETZ11Z8');
</script>


    <meta name="description" content="问题
这个问题是说，找到一个m*n大小的matrix中面积最大的正方形区域，这个区域满足里面全是1。
解析
这个问题一开始想的就是从一个坐标开始，以他为右下角的区域的找到最大的正方形，然后一直找知道找到右下角最终结果。类似那种网格问题一样。..." />
    <meta name="keywords" content="Dynamic Programming,LeetCode" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://10kshuaizhang.github.io">
  <img class="avatar" src="https://10kshuaizhang.github.io/images/avatar.png?v=1687157630552" alt="">
  </a>
  <h1 class="site-title">
    10K&#39;s
  </h1>
  <p class="site-description">
    Shortcuts are the farthest path, so you must write and think honestly, which is the basic requirement for progress.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu">
          Archive
        </a>
      
    
      
        <a href="/post/about" class="menu">
          About
        </a>
      
    
      
        <a href="/tags" class="menu">
          Tags
        </a>
      
    
      
        <a href="/post/books" class="menu">
          Books
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/10kshuaizhang" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/jason278642682" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              221. Maximal Square
            </h2>
            <div class="post-info">
              <span>
                2023-03-05
              </span>
              <span>
                4 min read
              </span>
              
                <a href="https://10kshuaizhang.github.io/tag/8XHIFnHCE/" class="post-tag">
                  # Dynamic Programming
                </a>
              
                <a href="https://10kshuaizhang.github.io/tag/4zkg5-iEk/" class="post-tag">
                  # LeetCode
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h2 id="问题">问题</h2>
<p>这个问题是说，找到一个m*n大小的matrix中面积最大的正方形区域，这个区域满足里面全是1。</p>
<h2 id="解析">解析</h2>
<p>这个问题一开始想的就是从一个坐标开始，以他为右下角的区域的找到最大的正方形，然后一直找知道找到右下角最终结果。类似那种网格问题一样。</p>
<p>但是后面一直卡在如何确认在当前状态下一个一这个点为边的正方形是满足条件的（都为1）。</p>
<p>直到看了解析，求面积最大其实就是求边最大。那么问题就没有和整个matrix割裂了。状态的定义就成了以他为右下角的区域的找到最大的边即可。</p>
<p>状态转移公式对于当前点来说就来自于他的上面，左边，或者左上方对角线的最小值（因为对于不论哪个方向要都满足才可以所以找的是最小值）。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-java">class Solution {
    public int maximalSquare(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dp = new int[m + 1][n + 1];
        int max = 0;
        
        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (matrix[i-1][j-1] == '1') {
                    dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;
                    max = Math.max(max, dp[i][j]);
                }
            }
        }
        return max * max;
    }
}
</code></pre>
<hr>
<h2 id="problem">Problem</h2>
<p>This problem is to find the largest square area in a matrix of size m*n that satisfies all 1's in it.</p>
<h2 id="solution">Solution</h2>
<p>The problem starts with the idea of finding the largest square in the area of the lower-right corner of the m*n matrix, and then looking for the final result in the lower-right corner. It is similar to the grid problem.</p>
<p>But later on, I was stuck on how to confirm that a square in the current state with this point as a side is satisfied (all 1).</p>
<p>Until I read the analysis, seeking the maximum area is actually seeking the maximum side. Then the problem is not cut off from the whole matrix. The definition of the state becomes to find the largest side of the area with him as the lower right corner can be.</p>
<p>The state transfer formula for the current point comes from the top, left, or top left diagonal of the minimum value (because for either direction to be satisfied to find the minimum value).</p>
<h2 id="code">Code</h2>
<pre><code class="language-java">class Solution {
    public int maximalSquare(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dp = new int[m + 1][n + 1];
        int max = 0;
        
        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (matrix[i-1][j-1] == '1') {
                    dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;
                    max = Math.max(max, dp[i][j]);
                }
            }
        }
        return max * max;
    }
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%97%AE%E9%A2%98">问题</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90">解析</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
<li><a href="#code">Code</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://10kshuaizhang.github.io/post/72-edit-distance/">
              <h3 class="post-title">
                72. Edit Distance
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '3f6a89270d2a0e51772d',
    clientSecret: '58f2d7ec868483233a31553fa6235f2efd1df763',
    repo: '10kshuaizhang.github.io',
    owner: '10kshuaizhang',
    admin: ['10kshuaizhang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  
  <a class="rss" href="https://10kshuaizhang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
