<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring实战(第四版)- part2(SpringMVC构建Web应用实例) | 10K&#39;s</title>
<link rel="shortcut icon" href="https://10kshuaizhang.github.io/favicon.ico?v=1687157630552">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://10kshuaizhang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Spring实战(第四版)- part2(SpringMVC构建Web应用实例) | 10K&#39;s - Atom Feed" href="https://10kshuaizhang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-L6PETZ11Z8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-L6PETZ11Z8');
</script>


    <meta name="description" content="第二部分 Web中的Spring
第五章 Spring MVC基本用法。如何编写处理 Web 请求的控制器以及如何透明地绑定请求参数和负载到业务对象上，同时它还提供了数据检验和错误处理的功能。
第六章 如何渲染Web视图。如何得到 Spri..." />
    <meta name="keywords" content="Spring,Java" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://10kshuaizhang.github.io">
  <img class="avatar" src="https://10kshuaizhang.github.io/images/avatar.png?v=1687157630552" alt="">
  </a>
  <h1 class="site-title">
    10K&#39;s
  </h1>
  <p class="site-description">
    Shortcuts are the farthest path, so you must write and think honestly, which is the basic requirement for progress.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu">
          Archive
        </a>
      
    
      
        <a href="/post/about" class="menu">
          About
        </a>
      
    
      
        <a href="/tags" class="menu">
          Tags
        </a>
      
    
      
        <a href="/post/books" class="menu">
          Books
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/10kshuaizhang" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/jason278642682" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring实战(第四版)- part2(SpringMVC构建Web应用实例)
            </h2>
            <div class="post-info">
              <span>
                2022-09-11
              </span>
              <span>
                52 min read
              </span>
              
                <a href="https://10kshuaizhang.github.io/tag/2LjrGhsYzm/" class="post-tag">
                  # Spring
                </a>
              
                <a href="https://10kshuaizhang.github.io/tag/YyW64XHFs/" class="post-tag">
                  # Java
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h2 id="第二部分-web中的spring">第二部分 Web中的Spring</h2>
<p>第五章 Spring MVC基本用法。如何编写处理 Web 请求的控制器以及如何透明地绑定请求参数和负载到业务对象上，同时它还提供了数据检验和错误处理的功能。</p>
<p>第六章 如何渲染Web视图。如何得到 Spring MVC 控制器所生成的模型数据，并将其渲染为用户浏览器中的 HTML。（JSP，Apache Tiles，Thymeleaf）</p>
<p>第七章 Spring MVC高级技术。包括自定义 Spring MVC 配置、处理 multipart 文件上传、处理异常以及使用 flash 属性跨请求传递数据。</p>
<p>第八章如何使用 Spring Web Flow 来构建会话式、基于流程的 Web 应用程序。</p>
<p>第九章如何使用 Spring Security 来为 Web 应用程序提供安全性。</p>
<h3 id="第五章-构建spring-web-application">第五章 构建Spring Web Application</h3>
<ul>
<li>映射请求到Spring控制器</li>
<li>透明的绑定表单参数</li>
<li>校验表单提交</li>
</ul>
<h4 id="51-spring-mvc起步">5.1 Spring MVC起步</h4>
<p>Spring将请求在调度Servlet、处理器映射（handler mapping）、控制器以及视图解析器之间移动。</p>
<h5 id="511-跟踪spring-mvc的请求">5.1.1 跟踪Spring MVC的请求</h5>
<img src="https://702021806-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LmcjU5gG__lBrRbUxBO%2F-LmnL9uj1BBeqswq8NzY%2F-LmnLQNIY6fIl5jgnX5t%2F5.1%20spring%20mvc%20%E8%AF%B7%E6%B1%82.jpg?alt=media&token=1d5044cb-c165-42a4-8578-4d47d64e3daf" alt="img" style="zoom:50%;" />
<ol>
<li>单例的前端控制器（DispatcherServlet）根据请求携带的URL信息查询一个或多个处理器映射（handler mapping），然后将请求发送给Spring MVC的控制器controller。</li>
<li>良好的控制器一般不怎么处理工作，它会将业务逻辑委托给服务对象进行处理；</li>
<li>Controller完成逻辑后产生的信息（model），标示出用来渲染的视图，打包发给DispatcherServlet；</li>
<li>DispatcherServlet通过返回的逻辑视图名称，利用视图解析器view resolver找到特定的视图实现；</li>
<li>将数据model交付给视图，视图渲染数据并返回给客户端。</li>
</ol>
<h5 id="512-搭建spring-mvc">5.1.2 搭建Spring MVC</h5>
<p><strong>配置DispatcherServlet</strong>：使用Java将DispatcherServlet 配置在 Servlet 容器中</p>
<pre><code class="language-java">package spittr.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class SpitterWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected String[] getServletMappings() {
    return new String[] { &quot;/&quot; }; // 映射请求
  }
  
  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() {
    return new Class&lt;?&gt;[] { RootConfig.class };
  } 

  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class&lt;?&gt;[] { WebConfig.class };
  }

}
</code></pre>
<p>容器查找SpringServletContainerInitializer类将配置工作交给它，SpringServletContainerInitializer又会去找WebApplicationInitializer的实现并将配置任务交给这个实现。AbstractAnnotationConfigDispatcherServletInitializer是WebApplicationInitializer的基础实现，SpitterWebInitializer继承它也是实现了<strong>WebApplicationInitializer</strong>。</p>
<p><strong>启动Spring MVC</strong></p>
<p>一个最简单的配置：</p>
<pre><code class="language-java">package spittr.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

@Configuration
@EnableWebMvc
public class WebConfig {
}
</code></pre>
<p>问题1：缺少视图解析器的话会使用默认的BeanNameViewResolver，这个视图解析器会查找 ID 与视图名称匹配的 bean，并且查找的 bean 要实现 View 接口，它以这样的方式来解析视图。；</p>
<p>问题2：没启动组件扫描，只能找到显式声明的控制器；</p>
<p>问题3：DispatcherServlet 会映射为应用的默认 Servlet，所以它会处理所有的请求，包括对静态资源的请求，如图片和样式表（在大多数情况下，这可能并不是你想要的效果）。</p>
<p>所以我们加一些东西：</p>
<pre><code class="language-java">package spittr.web;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
@EnableWebMvc
@ComponentScan(&quot;spittr.web&quot;)
public class WebConfig extends WebMvcConfigurerAdapter {

  @Bean
  public ViewResolver viewResolver() {
    InternalResourceViewResolver resolver = new InternalResourceViewResolver();
    resolver.setPrefix(&quot;/WEB-INF/views/&quot;);
    resolver.setSuffix(&quot;.jsp&quot;);
    return resolver;
  }
  
  @Override
  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
    configurer.enable(); // 通过调用 DefaultServletHandlerConfigurer 的 enable() 方法，我们要求 DispatcherServlet 将对静态资源的请求转发到 Servlet 容器中默认的 Servlet 上，而不是使用 DispatcherServlet 本身来处理此类请求。
  }
}
</code></pre>
<p>因为聚焦Web开发，所以RootConfig可以带过：</p>
<pre><code class="language-java">package spittr.config;

import java.util.regex.Pattern;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;
import org.springframework.web.servlet.config.annotation.EnableMvc;

@Configuration
@ComponentScan(basePackages={&quot;spittr&quot;}, 
    excludeFilters={
        @Filter(type=FilterType.ANNOTATION, value=EnableWebMvc.class)
    })
public class RootConfig {
}
</code></pre>
<h5 id="513-spittr应用简介">5.1.3 Spittr应用简介</h5>
<p>Spitter（应用的用户）和 Spittle（用户发布的简短状态更新）。</p>
<h4 id="52-编写基本的控制器">5.2 编写基本的控制器</h4>
<ol>
<li>
<p>控制器是类里的方法上加了@RequestMapping 注解的类，这个注解声明了它们要处理的请求。</p>
<pre><code class="language-java">package spittr.web;

import static org.springframework.web.bind.annotation.RequestMethod.*;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HomeController {

  @RequestMapping(value=&quot;/&quot;, method = GET)
  public String home(Model model) {
    return &quot;home&quot;;
  }

}
</code></pre>
<p>@Controller 是基于@Component，辅助组件实现扫描。Spring会在看到它后将它声明为一个bean。</p>
</li>
</ol>
<h5 id="521-测试控制器">5.2.1 测试控制器</h5>
<pre><code class="language-java">package spittr.web;

import static org.junit.Assert.asser¡12tEquals;
import org.junit.Test;
import spittr.web.HomeController;

public class HomeControllerTest {

  @Test
  public void testHomePage() throws Exception {
    HomeController controller = new HomeController();
    assertEuqals(&quot;home&quot;, controller.home());
  }

}
</code></pre>
<p>这个测试的问题在于它并没有以MVC的视角去测试，它只是看了controller里面会调用home()方法以及它会返回什么。</p>
<p>从Spring3.2开始，可以按照控制器的方式测试，它会不启动服务器发起请求：</p>
<pre><code class="language-java">package spittr.web;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.springframework.test.web.servlet.setup.MockMvcBuilders.*;

import org.junit.Test;
import org.springframework.test.web.servlet.MockMvc;

import spittr.web.HomeController;

public class HomeControllerTest {

  @Test
  public void testHomePage() throws Exception {
    HomeController controller = new HomeController();
    MockMvc mockMvc = standaloneSetup(controller).build();
    mockMvc.perform(get(&quot;/&quot;))
           .andExpect(view().name(&quot;home&quot;));
  }

}
</code></pre>
<h5 id="522-定义类级别的请求处理">5.2.2 定义类级别的请求处理</h5>
<ol>
<li>
<p>可以将@RequestMapping拆分并将路径映射部分放到类级别上</p>
<pre><code class="language-java">package spittr.web;

import static org.springframework.web.bind.annotation.RequestMethod.*;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(&quot;/&quot;)
// @RequesiMapping({&quot;/&quot;, &quot;/homepage&quot;})
public class HomeController {

  @RequestMapping(method = GET)
  public String home(Model model) {
    return &quot;home&quot;;
  }

}
</code></pre>
<p>类级别的注解会应用到它下面的所有处理器方法，处理器方法上的@RequestMapping会对其进行补充。</p>
</li>
<li>
<p>@RequestMapping 的 value 属性能够接受一个 String 类型的数组。</p>
</li>
</ol>
<h5 id="523-传递模型数据到视图中">5.2.3 传递模型数据到视图中</h5>
<ol>
<li>
<p>需要定义新方法来处理对于Spittr数据的展现</p>
</li>
<li>
<p>首先定义一个数据访问的Repository，接口可以实现解耦（参考此书第一部分）。</p>
<pre><code class="language-java">package spittr.data;

import java.util.List;
import spittr.Spittle;

public interface SpittleRepository {

  List&lt;Spittle&gt; findSpittles(long max, int count);

}
</code></pre>
</li>
<li>
<p>定义Spittle类</p>
<pre><code class="language-java">package spittr;

import java.util.Date;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

public class Spittle {

  private final Long id;
  private final String message;
  private final Date time;
  private Double latitude;
  private Double longitude;

  public Spittle(String message, Date time) {
    this(null, message, time, null, null);
  }
  
  public Spittle(Long id, String message, Date time, Double longitude, Double latitude) {
    this.id = id;
    this.message = message;
    this.time = time;
    this.longitude = longitude;
    this.latitude = latitude;
  }

  public long getId() {
    return id;
  }

  public String getMessage() {
    return message;
  }

  public Date getTime() {
    return time;
  }
  
  public Double getLongitude() {
    return longitude;
  }
  
  public Double getLatitude() {
    return latitude;
  }
  
  @Override
  public boolean equals(Object that) {
    return EqualsBuilder.reflectionEquals(this, that, &quot;id&quot;, &quot;time&quot;);
  }
  
  @Override
  public int hashCode() {
    return HashCodeBuilder.reflectionHashCode(this, &quot;id&quot;, &quot;time&quot;);
  }
  
}
</code></pre>
</li>
<li>
<p>对于这个Spittle对象，写一个测试来断言预期</p>
<pre><code class="language-java">@Test
public void shouldShowPagedSpittles() throws Exception {
  List&lt;Spittle&gt; expectedSpittles = createSpittleList(50);
  SpittleRepository mockRepository = mock(SpittleRepository.class);
  when(mockRepository.findSpittles(238900, 50))
      .thenReturn(expectedSpittles);
    
  SpittleController controller = new SpittleController(mockRepository);
  MockMvc mockMvc = standaloneSetup(controller)
      .setSingleView(new InternalResourceView(&quot;/WEB-INF/views/spittles.jsp&quot;))
      .build();

  mockMvc.perform(get(&quot;/spittles&quot;))
    .andExpect(view().name(&quot;spittles&quot;))
    .andExpect(model().attributeExists(&quot;spittleList&quot;))
    .andExpect(model().attribute(&quot;spittleList&quot;, hasItems(expectedSpittles.toArray())));
}

...
  
private List&lt;Spittle&gt; createSpittleList(int count) {
  List&lt;Spittle&gt; spittles = new ArrayList&lt;Spittle&gt;();
  for (int i=0; i &lt; count; i++) {
    spittles.add(new Spittle(&quot;Spittle &quot; + i, new Date()));
  }
  return spittles;
}
</code></pre>
<p>我们预期创建50个对象，并放进一个list中。当请求包含参数的地址时，可以返回名字为“spittles”的逻辑视图，包含了一个spittleList对象。</p>
</li>
<li>
<p>此处例子中因为MockMvc会因为无法区分视图路径和控制器路径因此失败，所以加上这个方法从而让它只使用这个view实例。</p>
<blockquote>
<p>Sets up a single <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/ViewResolver.html"><code>ViewResolver</code></a> that <strong>always returns the provided view instance</strong>. This is a convenient shortcut if you need to use one View instance only。</p>
</blockquote>
</li>
</ol>
<h4 id="53-接收请求的输入">5.3 接收请求的输入</h4>
<p>Spring MVC 允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括：</p>
<ul>
<li>查询参数（Query Parameter）</li>
<li>表单参数（Form Parameter）</li>
<li>路径变量（Path Variable）</li>
</ul>
<h5 id="531-处理查询参数">5.3.1 处理查询参数</h5>
<ol>
<li>
<p>在 Spittr 应用中，我们可能需要处理的一件事就是展现分页的 Spittle 列表。</p>
</li>
<li>
<p>在确定该如何实现时，假设我们要查看某一页 Spittle 列表，这个列表会按照最新的 Spittle 在前的方式进行排序。因此，下一页中第一条的 ID 肯定会早于当前页最后一条的 ID。所以，为了显示下一页的 Spittle，我们需要将一个 Spittle 的 ID 传入进来，这个 ID 要恰好小于当 前页最后一条 Spittle 的 ID。另外，你还可以传入一个参数来确定要展现的 Spittle 数量。</p>
</li>
<li>
<p>重写之前的测试，主要区别在于GET路径加入了查询参数：</p>
<pre><code class="language-java">@Test
public void shouldShowRecentSpittles() throws Exception {
  List&lt;Spittle&gt; expectedSpittles = createSpittleList(50);
  SpittleRepository mockRepository = mock(SpittleRepository.class);
  when(mockRepository.findSpittles(238900, 50))
    .thenReturn(expectedSpittles);

  SpittleController controller = new SpittleController(mockRepository);
  MockMvc mockMvc = standaloneSetup(controller)
      .setSingleView(new InternalResourceView(&quot;/WEB-INF/views/spittles.jsp&quot;))
      .build();

  mockMvc.perform(get(&quot;/spittles?max=238900&amp;count=50&quot;))
    .andExpect(view().name(&quot;spittles&quot;))
    .andExpect(model().attributeExists(&quot;spittleList&quot;))
    .andExpect(model().attribute(&quot;spittleList&quot;, hasItems(expectedSpittles.toArray())));
}
</code></pre>
</li>
<li>
<p>为了让SpittleController同时满足此处和5.2节中的请求，可以给它加上参数并且赋予默认值</p>
<pre><code class="language-java">private static final String MAX_LONG_AS_STRING = Long.toString(Long.MAX_VALUE);

@RequestMapping(method=RequestMethod.GET)
public List&lt;Spittle&gt; spittles(
  @RequestParam(value=&quot;max&quot;, defaultValue=MAX_LONG_AS_STRING) long max,
  @RequestParam(value=&quot;count&quot;, defaultValue=&quot;20&quot;) int count) {
    return spittleRepository.findSpittles(max, count);
}
</code></pre>
</li>
</ol>
<h5 id="532-通过路径参数接受输入">5.3.2 通过路径参数接受输入</h5>
<ol>
<li>
<p>构建面向资源的请求。</p>
</li>
<li>
<p>假设我们的应用程序需要根据给定的 ID 来展现某一个 Spittle 记录。按照上一节通过查询参数方式构造的请求会像这样：<code>/spittles/show?spittle_id=12345</code>， 从面向资源的角度不太理想。</p>
</li>
<li>
<p>理想状态是应该通过路径进行标识，而不是通过查询参数。对 <code>/spittles/12345</code> 发起 GET 请求要更好。</p>
</li>
<li>
<p><code>/spittles/12345</code> 能够识别出要查询的资源，而另外一种通过查询描述的是带有参数的一个操作 —— 本质上是通过 HTTP 发起的 RPC。</p>
</li>
<li>
<p>继续修改测试</p>
<pre><code class="language-java">@Test
public void testSpittle() throws Exception {
  Spittle expectedSpittle = new Spittle(&quot;Hello&quot;, new Date());
  SpittleRepository mockRepository = mock(SpittleRepository.class);
  when(mockRepository.findOne(12345)).thenReturn(expectedSpittle);
    
  SpittleController controller = new SpittleController(mockRepository);
  MockMvc mockMvc = standaloneSetup(controller).build();

  mockMvc.perform(get(&quot;/spittles/12345&quot;))
    .andExpect(view().name(&quot;spittle&quot;))
    .andExpect(model().attributeExists(&quot;spittle&quot;))
    .andExpect(model().attribute(&quot;spittle&quot;, expectedSpittle));
}
</code></pre>
</li>
<li>
<p>在@RequestMapping中添加占位符可以实现利用路径参数的请求。</p>
<pre><code class="language-java">@RequestMapping(value=&quot;/{spittleId}&quot;, method=RequestMethod.GET)
public String spittle(
    @PathVariable(&quot;spittleId&quot;) long spittleId, 
    Model model) {
  model.addAttribute(spittleRepository.findOne(spittleId));
  return &quot;spittle&quot;;
}
</code></pre>
<p>如果 @PathVariable 中没有 value 属性的话，它会假设占位符的名称与方法的参数名相同。</p>
</li>
</ol>
<h4 id="54-处理表单">5.4 处理表单</h4>
<ol>
<li>
<p>新建一个SpitterController来处理表单的提交</p>
<pre><code class="language-java">package spittr.web;

import static org.springframework.web.bind.annotation.RequestMethod.*;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.Errors;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

import spittr.Spitter;
import spittr.data.SpitterRepository;

@Controller
@RequestMapping(&quot;/spitter&quot;)
public class SpitterController {
  
  @RequestMapping(value=&quot;/register&quot;, method=GET)
  public String showRegistrationForm() {
    return &quot;registerForm&quot;;
  }

}
</code></pre>
</li>
<li>
<p>写一个测试</p>
<pre><code class="language-java">@Test
public void shouldShowRegistration() throws Exception {
  SpitterController controller = new SpitterController();
  MockMvc mockMvc = standaloneSetup(controller).build();
  
  mockMvc.perform(get(&quot;/spitter/register&quot;)).andExpect(view().name(&quot;registerForm&quot;));
}
</code></pre>
</li>
<li>
<p>渲染注册表单的JSP</p>
<pre><code class="language-jsp">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;%@ page session=&quot;false&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Spitter&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; 
          href=&quot;&lt;c:url value=&quot;/resources/style.css&quot; /&gt;&quot; &gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Register&lt;/h1&gt;

    &lt;form method=&quot;POST&quot;&gt;
      First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot; /&gt;&lt;br/&gt;
      Last Name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; /&gt;&lt;br/&gt;
      Email: &lt;input type=&quot;email&quot; name=&quot;email&quot; /&gt;&lt;br/&gt;
      Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;
      Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt;
      &lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这里的标签中并没有设置 action 属性。在这种情况下，当表单提交时它会提交到与展现时相同的 URL 路径上，即提交到 <code>/spitter/register</code> 上。这意味着需要在服务器端处理该 HTTP POST 请求。</p>
</li>
</ol>
<h5 id="541-编写处理表单的控制器">5.4.1 编写处理表单的控制器</h5>
<ol>
<li>
<p>为了处理表单POST请求，控制器会接收表单数据并保存为Spittr对象。为了防止用户刷新重复提交会做重定向处理。</p>
</li>
<li>
<p>写个测试， 构建一下预期（TDD？）</p>
<pre><code class="language-java">@Test
public void shouldProcessRegistration() throws Exception {
  SpitterRepository mockRepository = mock(SpitterRepository.class);
  Spitter unsaved = new Spitter(&quot;jbauer&quot;, &quot;24hours&quot;, &quot;Jack&quot;, &quot;Bauer&quot;, &quot;jbauer@ctu.gov&quot;);
  Spitter saved = new Spitter(24L, &quot;jbauer&quot;, &quot;24hours&quot;, &quot;Jack&quot;, &quot;Bauer&quot;, &quot;jbauer@ctu.gov&quot;);
  when(mockRepository.save(unsaved)).thenReturn(saved);
    
  SpitterController controller = new SpitterController(mockRepository);
  MockMvc mockMvc = standaloneSetup(controller).build();

  mockMvc.perform(post(&quot;/spitter/register&quot;)
         .param(&quot;firstName&quot;, &quot;Jack&quot;)
         .param(&quot;lastName&quot;, &quot;Bauer&quot;)
         .param(&quot;username&quot;, &quot;jbauer&quot;)
         .param(&quot;password&quot;, &quot;24hours&quot;)
         .param(&quot;email&quot;, &quot;jbauer@ctu.gov&quot;))
         .andExpect(redirectedUrl(&quot;/spitter/jbauer&quot;));
    
  verify(mockRepository, atLeastOnce()).save(unsaved);
}
</code></pre>
</li>
<li>
<p>定义Controller</p>
<pre><code class="language-java">package spittr.web;

import static org.springframework.web.bind.annotation.RequestMethod.*;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.Errors;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

import spittr.Spitter;
import spittr.data.SpitterRepository;

@Controller
@RequestMapping(&quot;/spitter&quot;)
public class SpitterController {

  private SpitterRepository spitterRepository;

  @Autowired
  public SpitterController(SpitterRepository spitterRepository) {
    this.spitterRepository = spitterRepository;
  }
  
  @RequestMapping(value=&quot;/register&quot;, method=GET)
  public String showRegistrationForm() {
    return &quot;registerForm&quot;;
  }
  
  @RequestMapping(value=&quot;/register&quot;, method=POST)
  public String processRegistration(Spitter spitter) {    
    spitterRepository.save(spitter);
    return &quot;redirect:/spitter/&quot; + spitter.getUsername();
  }
  
}
</code></pre>
</li>
<li>
<p>InternalResourceViewResolver 还能识别forward。forward做一次请求，redirect做两次。</p>
<blockquote>
<p>两者区别：A找B借钱，B再去找C，这就是forward；A让B去找C，相当于A又去发一次借的请求，这是redirect。</p>
</blockquote>
</li>
<li>
<p>当我们重定向到用户个人信息页面，需要添加一个方法来处理这个Spittr对象将其展示：</p>
<pre><code class="language-java">@RequestMapping(value=&quot;/{username}&quot;, method=GET)
public String showSpitterProfile(@PathVariable String username, Model model) {
  Spitter spitter = spitterRepository.findByUsername(username);
  model.addAttribute(spitter);
  return &quot;profile&quot;;
}
</code></pre>
</li>
</ol>
<h5 id="542-校验表单">5.4.2 校验表单</h5>
<ol>
<li>
<p>对用户提交的数据基于安全性（e.g. 不能是一些注入语句）或者是业务要求（日期、电话、卡号要满足一定的格式），都需要进行校验。</p>
</li>
<li>
<p>在processRegistration里面虽然可以加if...else...，但是随着越来越多的信息和业务逻辑，这个地方会变得异常庞大和复杂，且搞乱了本身要做的事情。</p>
</li>
<li>
<p>从 Spring 3.0 开始，在 Spring MVC 中提供了对 Java 校验 API 的支持。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>@AssertFalse</td>
<td>所注解的元素必须是 Boolean 类型，并且值为 false</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>所注解的元素必须是 Boolean 类型，并且值为 true</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>所注解的元素必须是数字，并且它的值要小于或等于给定的  BigDecimalString 值</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>所注解的元素必须是数字，并且它的值要大于或等于给定的  BigDecimalString 值</td>
</tr>
<tr>
<td>@Digits</td>
<td>所注解的元素必须是数字，并且它的值必须有指定的位数</td>
</tr>
<tr>
<td>@Future</td>
<td>所注解的元素的值必须是一个将来的日期</td>
</tr>
<tr>
<td>@Max</td>
<td>所注解的元素必须是数字，并且它的值要大于或等于给定的值</td>
</tr>
<tr>
<td>@Min</td>
<td>所注解的元素必须是数字，并且它的值要小于或等于给定的值</td>
</tr>
<tr>
<td>@NotNull</td>
<td>所注解元素的值必须不能为 null</td>
</tr>
<tr>
<td>@Null</td>
<td>所注解元素的值必须为 null</td>
</tr>
<tr>
<td>@Past</td>
<td>所注解的元素的值必须是一个已过去的日期</td>
</tr>
<tr>
<td>@Pattern</td>
<td>所注解的元素的值必须匹配给定的正则表达式</td>
</tr>
<tr>
<td>@Size</td>
<td>所注解的元素的值必须是 String、集合或数组，并且它的长度要符合给定的范围</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>也可以自定义一些注解限制。</p>
</li>
<li>
<p>Spittr可以加上一些注解</p>
<pre><code class="language-java">package spittr;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

public class Spitter {

  private Long id;
  
  @NotNull
  @Size(min=5, max=16)
  private String username;

  @NotNull
  @Size(min=5, max=25)
  private String password;
  
  @NotNull
  @Size(min=2, max=30)
  private String firstName;

  @NotNull
  @Size(min=2, max=30)
  private String lastName;
  
  ...
}
</code></pre>
</li>
<li>
<p>Spitter 参数添加了 @Valid 注解，这会告知 Spring，需要确保这个对象满足校验限制。</p>
<pre><code class="language-java">@RequestMapping(value=&quot;/register&quot;, method=POST)
public String processRegistration(
    @Valid Spitter spitter, 
    Errors errors) {
  if (errors.hasErrors()) {
    return &quot;registerForm&quot;;
  }
    
  spitterRepository.save(spitter);
  return &quot;redirect:/spitter/&quot; + spitter.getUsername();
}
</code></pre>
<p>如果有校验出现错误的话，那么这些错误可以通过 Errors 对象进行访问，现在这个对象已作为 processRegistration() 方法的参数。（很重要一点需要注意: <strong><u>Errors 参数要紧跟在带有 @Valid 注解的参数后面</u></strong>，@Valid 注解所标注的就是要检验的参数。）processRegistration() 方法所做的第一件事就是调用Errors.hasErrors() 来检查是否有错误。</p>
</li>
</ol>
<h4 id="55-小结">5.5 小结</h4>
<h3 id="第六章-渲染web视图">第六章 渲染Web视图</h3>
<ul>
<li>将模型数据渲染为 HTML</li>
<li>使用 JSP 视图</li>
<li>通过 tiles 定义视图布局</li>
<li>使用 Thymeleaf 视图</li>
</ul>
<p>本章讨论视图以及渲染视图。</p>
<h4 id="61-理解视图解析">6.1 理解视图解析</h4>
<ol>
<li>
<p>将请求处理的逻辑**<u>和视图渲染解耦</u>**也是Spring MVC重要特性</p>
</li>
<li>
<p>Spring视图解析器的内部实现</p>
<pre><code class="language-java">public interface ViewResolver {
  View resolverViewName(String viewName, Locale locale) throws Exception;
}
</code></pre>
<p>resolverViewName会返回一个<strong>View</strong>实例。</p>
<pre><code class="language-java">public interface View {

  String getContentType();
  
  void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServlectResponse response) throws Exception;
}
</code></pre>
</li>
<li>
<p>Spring提供了多个内置实现</p>
<table>
<thead>
<tr>
<th>视图解析器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BeanNameViewResolver</td>
<td>将视图解析为 Spring 应用上下文中的 bean，其中 bean 的 ID 与视图的名字相同</td>
</tr>
<tr>
<td>ContentNegotiatingViewResolver</td>
<td>通过考虑客户端需要的内容类型来解析视图， 委托给另外一个能够产生对应内容类型的视图解析器</td>
</tr>
<tr>
<td>FreeMarkerViewResolver</td>
<td>将视图解析为 FreeMarker 模板</td>
</tr>
<tr>
<td>InternalResourceViewResolver</td>
<td>将视图解析为 Web 应用的内部资源（一般为 JSP）</td>
</tr>
<tr>
<td>JasperReportsViewResolver</td>
<td>将视图解析为 JasperReports 定义</td>
</tr>
<tr>
<td>ResourceBundleViewResolver</td>
<td>将视图解析为资源 bundle（一般为属性文件）</td>
</tr>
<tr>
<td>TilesViewResolver</td>
<td>将视图解析为 Apache Tile 定义，其中 tile ID 与视图名称相同。注意有两个不同的 TilesViewResolver 实现，分别对应于 Tiles 2.0 和 Tiles 3.0</td>
</tr>
<tr>
<td>UrlBasedViewResolver</td>
<td>直接根据视图的名称解析视图，视图的名称会匹配一个物理视图的定义</td>
</tr>
<tr>
<td>VelocityLayoutViewResolver</td>
<td>将视图解析为 Velocity 布局，从不同的Velocity 模板中组合页面</td>
</tr>
<tr>
<td>VelocityViewResolver</td>
<td>将视图解析为 Velocity 模板</td>
</tr>
<tr>
<td>XmlViewResolver</td>
<td>将视图解析为特定 XML 文件中的 bean 定义。类似于 BeanNameViewResolver</td>
</tr>
<tr>
<td>XsltViewResolver</td>
<td>将视图解析为 XSLT 转换后的结果</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="62-创建jsp视图">6.2 创建JSP视图</h4>
<p>Spring提供支持JSP方式</p>
<ul>
<li>InternalResourceViewResolver 会将视图名解析为 JSP 文件，如果在你的 JSP 页面中使用了 JSP 标准标签库 （JavaServer Pages Standard Tag Library，JSTL）的话，InternalResourceViewResolver 能够将视图名解析为  JstlView 形式的 JSP 文件，从而将 JSTL 本地化和资源 bundle 变量暴露给JSTL的格式化（formatting）和信息（message）标签。</li>
<li>Spring 提供了两个 JSP 标签库，一个用于表单到模型的绑定，另一个提供了通用的工具类特性。</li>
</ul>
<h5 id="621-配置适用于jsp的视图解析">6.2.1 配置适用于JSP的视图解析</h5>
<ol>
<li>
<p>InternalResourceViewResolver遵循一种约定，会在视图名上添加前缀和后缀，进而确定一个 Web 应用中视图资源的物理路径。</p>
</li>
<li>
<p>前文中home页面的例子</p>
<pre><code class="language-java">@Bean
public ViewResolver viewResolver() {
  InternalResourceViewResolver resolver = new InternalResourceViewResolver();
  resolver.setPrefix(&quot;/WEB-INF/views&quot;);
  resolver.setSuffix(&quot;.jsp&quot;);
  return resolver;
}
</code></pre>
 <img src="https://702021806-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LmcjU5gG__lBrRbUxBO%2F-Lms9Z-Ub9LRu8hyObLk%2F-LmsA2Ek3B56ZZW0OVDS%2F6.1%20jsp%20%E8%A7%A3%E6%9E%90%E5%99%A8.jpg?alt=media&token=b1e0b952-f341-4278-8a35-5bb0241edffc" alt="img" style="zoom:50%;" />
</li>
<li>
<p>也可以基于XML去配置。</p>
</li>
<li>
<p>当逻辑视图带有斜线时，如：books/detail 将会解析为 <code>/WEB-INF/views/books/detail.jsp</code>， 它可以带入到物理视图的渲染。这样可以允许我们组织文件，并且清晰的使用层级结构。</p>
</li>
</ol>
<p><strong>解析JSTL视图</strong></p>
<ol>
<li>
<p>如果这些 JSP 使用 JSTL 标签来处理格式化和信息的话，那么我们会希望 InternalResourceViewResolver 将视图解析为 JstlView</p>
</li>
<li>
<p>让InternalResourceViewResolver将视图渲染为jstlView只需要设置一下setViewClass即可（XML也可以配置）:</p>
<pre><code class="language-java">@Bean
public ViewResolver viewResolver() {
  InternalResourceViewResolver resolver = new InternalResourceViewResolver();
  resolver.setPrefix(&quot;/WEB-INF/views&quot;);
  resolver.setSuffix(&quot;.jsp&quot;);
  resolver.setViewClass(org.springframework.web.service.view.JstlView.class);
  return resolver;
}
</code></pre>
</li>
</ol>
<h5 id="622-使用spring的jsp库">6.2.2 使用Spring的JSP库</h5>
<ol>
<li>Spring提供的标签可以避免在脚本中写入过多的Java代码</li>
<li>Spring提供两种，一种是将基于HTML标签的，将表单绑定到模型，另一种是一些工具标签。</li>
</ol>
<p><strong>将表单绑定到模型</strong></p>
<ol>
<li>
<p>首先需要声明：<code>&lt;%@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;sf&quot; %&gt;</code></p>
</li>
<li>
<p>一共提供了14种标签</p>
<table>
<thead>
<tr>
<th>JSP标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;sf:checkbox&gt;</td>
<td>渲染成一个HTML 标签，其中type属性设置 为checkbox</td>
</tr>
<tr>
<td>&lt;sf:checkboxes&gt;</td>
<td>渲染成多个 HTML &lt;input&gt; 标签，其中 type 属性设置为 checkbox</td>
</tr>
<tr>
<td>&lt;sf:errors&gt;</td>
<td>在一个 HTML &lt;span&gt; 中渲染输入域的错误</td>
</tr>
<tr>
<td>&lt;sf:form&gt;</td>
<td>渲染成一个 HTML &lt;form&gt; 标签，并为其内部标签暴露绑定路径，用于数据绑定</td>
</tr>
<tr>
<td>&lt;sf:hidden&gt;</td>
<td>渲染成一个 HTML &lt;input&gt; 标签，其中 type 属性设置为 hidden</td>
</tr>
<tr>
<td>&lt;sf:input&gt;</td>
<td>渲染成一个 HTML &lt;input&gt; 标签，其中 type 属性设置为 text</td>
</tr>
<tr>
<td>&lt;sf:label&gt;</td>
<td>渲染成一个 HTML &lt;label&gt; 标签</td>
</tr>
<tr>
<td>&lt;sf:option&gt;</td>
<td>渲染成一个 HTML 标签，其 selected 属性根据所绑定的值进行设置</td>
</tr>
<tr>
<td>&lt;sf:options&gt;</td>
<td>按照绑定的集合、数组或 Map，渲染成一个 HTML 标签的列表</td>
</tr>
<tr>
<td>&lt;sf:password&gt;</td>
<td>渲染成一个HTML 标签，其中type属性设置 为password</td>
</tr>
<tr>
<td>&lt;sf:radiobutton&gt;</td>
<td>渲染成一个 HTML &lt;input&gt; 标签，其中 type 属性设置为 radio</td>
</tr>
<tr>
<td>&lt;sf:radiobuttons&gt;</td>
<td>渲染成多个 HTML &lt;input&gt; 标签，其中 type 属性设置为 radio</td>
</tr>
<tr>
<td>&lt;sf:select&gt;</td>
<td>渲染为一个 HTML &lt;select&gt; 标签</td>
</tr>
<tr>
<td>&lt;sf:textarea&gt;</td>
<td>渲染为一个 HTML &lt;textarea&gt; 标签</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>应用到Spittr应用的用户注册页面：</p>
<pre><code class="language-jsp">&lt;sf:form method=&quot;POST&quot; commandName=&quot;spitter&quot; &gt;
  First Name: &lt;sf:input path=&quot;firstName&quot; /&gt;&lt;br/&gt;
  Last Name: &lt;sf:input path=&quot;lastName&quot; /&gt;&lt;br/&gt;
  Email: &lt;sf:input path=&quot;email&quot; /&gt;&lt;br/&gt;
  Username: &lt;sf:input path=&quot;username&quot; /&gt;&lt;br/&gt;
  Password: &lt;sf:password path=&quot;password&quot; /&gt;&lt;br/&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;
&lt;/sf:form&gt;
</code></pre>
<p><code>&lt;sf:form&gt;</code> 会渲染会一个 HTML &lt;form&gt; 标签，但它也会通过 commandName 属性构建针对某个模型对象的上下文信息。</p>
<p>所以相应的。在controller中需要传一个对象给它：</p>
<pre><code class="language-java">@RequestMapping(value=&quot;/register&quot;, method=GET)
public String showRegistrationForm(Model model) {
  model.addAttribute(new Spitter());
  return &quot;registerForm&quot;;
}
</code></pre>
</li>
<li>
<p>还可以指定文本域的类型信息<code>Email: &lt;sf:input path=&quot;email&quot; type=&quot;email&quot; /&gt;&lt;br/&gt;</code></p>
</li>
</ol>
<p><strong>展现错误</strong></p>
<ol>
<li>
<p>如果存在校验错误的话，请求中会包含错误的详细信息，这些信息是与模型数据放到一起的。</p>
<pre><code class="language-jsp">&lt;sf:form method=&quot;POST&quot; commandName=&quot;spitter&quot;&gt;
  First Name: &lt;sf:input path=&quot;fisrtName&quot; /&gt;
             &lt;sf:errors path=&quot;firstName&quot; /&gt;&lt;br/&gt;
  ...
&lt;/sf:form&gt;
</code></pre>
<p>如果没错，则不会渲染error这一块，如果有错误则会渲染如下：</p>
<pre><code class="language-html">First Name: &lt;input id=&quot;firstName&quot; name=&quot;firstName&quot; type=&quot;text&quot; value=&quot;J&quot; /&gt;
&lt;span id=&quot;firstName.errors&quot;&gt;size must be between 2 and 30&lt;/span&gt;
</code></pre>
</li>
<li>
<p>本地化让应用变得更加友好易读。</p>
<ol>
<li>
<p>首先修改下Spittr定义类，如果没有大括号的话，message 中的值将会作为展现给用户的错误信息。但是使用了大括号之后，我们使用的就是属性文件中的某一个属性，该属性包含了实际的信息。</p>
<pre><code class="language-java">@NotNull
@Size(min=5, max=16, message=&quot;{username.size}&quot;)
private String username;

@NotNull
@Size(min=5, max=25, message=&quot;{password.size}&quot;)
private String password;
  
@NotNull
@Size(min=2, max=30, message=&quot;{firstName.size}&quot;)
private String firstName;

@NotNull
@Size(min=2, max=30, message=&quot;{lastName.size}&quot;)
private String lastName;
  
@NotNull
@Email(message=&quot;{email.valid}&quot;)
private String email;
</code></pre>
</li>
<li>
<p>定义一个property文件，放在根目录下：</p>
<pre><code class="language-properties">firstName.size=First name must be between {min} and {max} characters long.
lastName.size=Last name must be between {min} and {max} characters long.
username.size=Username must be between {min} and {max} characters long.
password.size=Password must be between {min} and {max} characters long.
email.valid=The email address must be valid.
</code></pre>
<p>min和max会取自 @Size 注解上所设置的 min 和 max 属性。</p>
</li>
<li>
<p>将这些错误信息抽取到属性文件中还会带来一个好处，那就是我们可以通过**<u>创建地域相关的属性文件</u>**，为用户展现特定语言和地域的信息。例如，如果用户的浏览器设置成了西班牙语，那么就应该用西班牙语展现错误信息，我们需要创建一个名为 ValidationErrors_es.properties 的文件</p>
</li>
</ol>
<p><strong>Spring通用标签库</strong></p>
<ol>
<li>
<p>同样首先要声明：<code>&lt;%@ taglib uri=&quot;http://www.springframework.org/tags&quot; prefix=&quot;s&quot; %&gt;</code></p>
</li>
<li>
<p>有10个标签</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;s:bind&gt;</td>
<td>将绑定属性的状态导出到一个名为 status 的页面作用域属性 中，与 &lt;s:path&gt; 组合使用获取绑定属性的值</td>
</tr>
<tr>
<td>&lt;s:escapeBody&gt;</td>
<td>将标签体中的内容进行 HTML 和 / 或 JavaScript 转义</td>
</tr>
<tr>
<td>&lt;s:hasBindErrors&gt;</td>
<td>根据指定模型对象（在请求属性中）是否有绑定错误，有条件地渲染内容</td>
</tr>
<tr>
<td>&lt;s:htmlEscape&gt;</td>
<td>为当前页面设置默认的 HTML 转义值</td>
</tr>
<tr>
<td>&lt;s:message&gt;</td>
<td>根据给定的编码获取信息，然后要么进行渲染（默认行为），要么将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</td>
</tr>
<tr>
<td>&lt;s:nestedPath&gt;</td>
<td>设置嵌入式的 path，用于 &lt;s:bind&gt; 之中</td>
</tr>
<tr>
<td>&lt;s:theme&gt;</td>
<td>根据给定的编码获取主题信息，然后要么进行渲染（默认行 为），要么将其设置为页面作用域、请求作用域、会话作用 域或应用作用域的变量（通过使用 var 和 scope 属性实现）</td>
</tr>
<tr>
<td>&lt;s:transform&gt;</td>
<td>使用命令对象的属性编辑器转换命令对象中不包含的属性</td>
</tr>
<tr>
<td>&lt;s:url&gt;</td>
<td>创建相对于上下文的 URL，支持 URI 模板变量以及  HTML/XML/JavaScript 转义。可以渲染 URL（默认行为），也可以将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</td>
</tr>
<tr>
<td>&lt;s:eval&gt;</td>
<td>计算符合 Spring 表达式语言（Spring Expression Language， SpEL）语法的某个表达式的值，然后要么进行渲染（默认行为），要么将其设置为页面作用域、请求作用域、会话作用域或应用作用域的变量（通过使用 var 和 scope 属性实现）</td>
</tr>
</tbody>
</table>
<p><strong>展现国际化信息</strong></p>
<ol>
<li>
<p>如果你在模板文件中写的是中文，但是这个应用部署到其他国家，所有用户看的都是中文，而且如果要改需要去改全部模板。（类似硬编码）</p>
</li>
<li>
<p>对于渲染文本来说，是很好的方案，文本能够位于一个或多个属性文件中。借助 <code>&lt;s:message&gt;</code>，我们可以将硬编码的欢迎信息替换为如下的形式：<code>&lt;h1&gt;&lt;s:message code=&quot;spitter.welcome&quot; /&gt;&lt;/h1&gt;</code></p>
</li>
<li>
<p>ResourceBundleMessageSource。它会从一个属性文件中加载信息，这个属性文件的名称是根据基础名称（base name）衍生而来的。如下的 @Bean 方法配置了 ResourceBundleMessageSource：</p>
<pre><code class="language-java">@Bean
public MessageSource messageSource() {
  ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
  messageSource.setBasename(&quot;messages&quot;);
  return messageSource;
}
</code></pre>
<p>在这个 bean 声明中，核心在于设置 basename 属性。你可以将其设置为任意你喜欢的值，在这里，我将其设置为  message。将其设置为 message 后，ResourceBundleMessageSource 就会试图在根路径的属性文件中解析信息，这些属性文件的名称是根据这个基础名称衍生得到的。</p>
</li>
<li>
<p>另外的可选方案是使用 ReloadableResourceBundleMessageSource，它的工作方式与 ResourceBundleMessageSource 非常类似，但是它能够重新加载信息属性，而不必重新编译或重启应用。如下是配置ReloadableResourceBundleMessageSource 的样例：</p>
<pre><code class="language-java">@Bean
public MessageSource messageSource() {
  ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
  messageSource.setBasename(&quot;file:///etc/spitter/messages&quot;);
  messageSource.setCacheSeconds(10);
  return messageSource;
}
</code></pre>
</li>
<li>
<p>创建默认属性文件messages.properties，目前来说至少要包含<code>spitter.welcome=Welcome to Spittr!</code></p>
</li>
<li>
<p>为了国际化，创建另外一个名为 messages_es.properties 的属性文件<code>spittr.welcome=Bienvenidos a Spittr!</code></p>
</li>
</ol>
<p><strong>创建URL</strong></p>
<p><code>&lt;s:url&gt;</code>:  创建 URL，然后将其赋值给一个变量或者渲染到响应中。是<code>&lt;c:url&gt;</code>的替代者。</p>
<ul>
<li>
<p>如果希望在 URL 上添加参数的话，那么你可以使用 <code>&lt;s:param&gt;</code> 标签。比如，如下的 <code>&lt;s:url&gt;</code> 使用两个内嵌的 <code>&lt;s:param&gt;</code> 标签，来设置 <code>/spittles</code> 的 max 和 count 参数：</p>
<pre><code class="language-jsp">&lt;s:url href=&quot;/spittles&quot; var=&quot;spittlesUrl&quot;&gt;
  &lt;s:param name=&quot;max&quot; value=&quot;60&quot; /&gt;
  &lt;s:param name=&quot;count&quot; value=&quot;20&quot; /&gt;
&lt;/s:url&gt;
</code></pre>
</li>
<li>
<p>如果希望创建带有路径参数的url，可以使用<code>&lt;s:url&gt;</code>特有的：</p>
<pre><code class="language-jsp">&lt;s:url href=&quot;/spitter/{username}&quot; var=&quot;spitterUrl&quot;&gt;
  &lt;s:param name=&quot;username&quot; value=&quot;jbauer&quot; /&gt;
&lt;/s:url&gt;
</code></pre>
</li>
</ul>
<p><strong>转义内容</strong></p>
<p><code>&lt;s:escapeBody&gt;</code> 标签是一个通用的转义标签。它会渲染标签体中内嵌的内容，并且在必要的时候进行转义。例如，假设你希望在页面上展现一个 HTML 代码片段。为了正确显示，我们需要将 <code>&lt;</code> 和<code> &gt;</code> 字符替换为 <code>&lt;</code> 和 <code>&gt;</code>，否则的话，浏览器将会像解析页面上其他 HTML 那样解析这段 HTML 内容。</p>
</li>
</ol>
</li>
</ol>
<h4 id="63-使用apache-tiles视图定义布局">6.3 使用Apache Tiles视图定义布局</h4>
<h5 id="631-配置tiles视图解析器">6.3.1 配置Tiles视图解析器</h5>
<p>略</p>
<h4 id="64-使用thymeleaf">6.4 使用Thymeleaf</h4>
<ul>
<li>JSP标签库与HTML混和降低可读性，而且因为其不是真正的HTML，在不同的浏览器渲染的也不尽人意可能。</li>
<li>JSP规范和Servlet规范耦合，只能应用在基于Servlet的Web应用。</li>
</ul>
<h5 id="641-配置thymeleaf视图解析器">6.4.1 配置Thymeleaf视图解析器</h5>
<p>为了要在 Spring 中使用 Thymeleaf，我们需要配置三个启用 Thymeleaf 与 Spring 集成的 bean：</p>
<ul>
<li>ThymeleafViewResolver：将逻辑视图名称解析为 Thymeleaf 模板视图；</li>
<li>SpringTemplateEngine：处理模板并渲染结果；</li>
<li>TemplateResolver：加载 Thymeleaf 模板。</li>
</ul>
<h5 id="642-定义thymeleaf模板">6.4.2 定义Thymeleaf模板</h5>
<ol>
<li>
<p>就是HTML，没标签库。发挥作用依靠**<u>自定义命名空间</u>**。</p>
<pre><code class="language-html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;Spitter&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; 
          type=&quot;text/css&quot; 
          th:href=&quot;@{/resources/style.css}&quot;&gt;&lt;/link&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;content&quot;&gt;
      &lt;h1&gt;Welcome to Spitter&lt;/h1&gt;
  
      &lt;a th:href=&quot;@{/spittles}&quot;&gt;Spittles&lt;/a&gt; | 
      &lt;a th:href=&quot;@{/spitter/register}&quot;&gt;Register&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
<h4 id="65-小结">6.5 小结</h4>
<h3 id="第七章-spring-mvc-高级技术">第七章 Spring MVC 高级技术</h3>
<ul>
<li>SpringMVC配置的替代方案</li>
<li>处理文件上传</li>
<li>在控制器中处理异常</li>
<li>使用flash属性</li>
</ul>
<h4 id="71-spring-mvc配置的替代方案">7.1 Spring MVC配置的替代方案</h4>
<p>AbstractAnnotationConfigDispatcherServletInitializer基本的配置可能并不满足我们的需求；除了DispatcherServlet以外我们还需要额外的Servlet和Filter；可能需要对DispatcherServlet本身做一些配置；亦或者需要将应用配置到Spring3.0之前的容器，需要将Servlet配置在web.xml中。</p>
<h5 id="711-自定义dispatcherservlet配置">7.1.1 自定义DispatcherServlet配置</h5>
<ol>
<li>之前的SpitterServletInitializer只是实现了必须实现的三个方法，还有其他方法可以实现进行额外配置。</li>
<li>例如<code>customizeRegistration()</code>。在AbstractAnnotationConfigDispatcherServletInitializer将DispatcherServlet注册到Servlet容器中之后，就会调用这个方法，可以对DispatcherServlet进行额外配置。
<ul>
<li>setLoadOnStartup() 设置 load-on-startup 优先级</li>
<li>setInitParameter() 设置初始化参数</li>
<li>setMultipartConfig() 配置 Servlet 3.0 对 multipart 的支持</li>
</ul>
</li>
</ol>
<h5 id="712-添加其他的servlet和filter">7.1.2 添加其他的Servlet和Filter</h5>
<ol>
<li>
<p>基于Java的initializer可以让我们定义任意数量的初始化器类。如果想在Web容器注册其他组件，只需要创建一个新的初始化器即可。</p>
<pre><code class="language-java">package com.myapp.config;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRegistration.Dynamic;
import org.springframework.web.WebApplicationInitializer;
import com.myapp.MyServlet;

public class MyServletInitializer extends WebApplicationInitializer {
    @Override
    public void onStartup(ServeletContext servletContext) throws ServletException {
        Dynamic myServlet = servletContext.addServlet(&quot;myServelet&quot;, MyServlet.calss);
        
        myServelet.addMapping(&quot;/custom/**&quot;);
    }
}
</code></pre>
</li>
<li>
<p>类似的也可以创建新的WebApplicationInitializer实现来注册Listener和Filter，Spring3.0提供了一种通用方式：</p>
<pre><code class="language-java">@Override
public void onStartup(ServlectContext servletContext) throws ServletException {

  javax.servlet.FilterRegistration.Dynamic filter = servletContext.addFilter(&quot;myFilter&quot;, MyFilter.class);
  
  filter.addMappingForUrlPatterns(null, false, &quot;/custom/**&quot;);
} 
</code></pre>
<p>另外还有更快捷方式，只需重载getServletFilters方法：</p>
<pre><code class="language-java">@Override
protected Filter() getServletFilters() {
  return new Filter[] { new MyFilter() };
}
</code></pre>
<p>他返回的所有filter都会映射到DispatcherServlet上。</p>
</li>
</ol>
<h5 id="713-在webxml中声明dispatcherservlet">7.1.3 在web.xml中声明DispatcherServlet</h5>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app version=&quot;2.5&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
  xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
      http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; &gt;

  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;listener&gt;
    &lt;listener-class&gt;
      org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      org.springframework.web.servlet.DispatcherServlet
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<p>而且还可以通过指定配置类的位置，在web.xml中使用Java配置类。</p>
<h4 id="72-处理multipart形式的数据">7.2 处理multipart形式的数据</h4>
<p>multipart 格式的数据会将一个表单拆分为多个部分（part），每个部分对应一个输入域。在一般的表单输入域中，它所对应的部分中会放置文本型数据，但是如果上传文件的话，它所对应的部分可以是二进制，下面展现了 multipart 的请求体：</p>
<pre><code>-----------WebKitFormBoundaryqgkaBn8lHJCuNmiW
Content-Disposition: form-data; name=&quot;firstName&quot;

Charles
-----------WebKitFormBoundaryqgkaBn8lHJCuNmiW
Content-Disposition: form-data; name=&quot;lastName&quot;

Xavier
-----------WebKitFormBoundaryqgkaBn8lHJCuNmiW
Content-Disposition: form-data; name=&quot;email&quot;

charles@xmen.com
-----------WebKitFormBoundaryqgkaBn8lHJCuNmiW
&quot;Content-Disposition: form-data; name=&quot;username&quot;

professorx
-----------WebKitFormBoundaryqgkaBn8lHJCuNmiW
Content-Disposition: form-data; name=&quot;password&quot;

letmeinO1
-----------WebKitFormBoundaryqgkaBn8lHJCuNmiW
Content-Disposition: form-data; name=&quot;profilePicture&quot;; filename=&quot;me.jpg&quot;

Content-Type: image/jpeg

  [[ Binary image data goes here ]]
-----------WebKitFormBoundaryqgkaBn8lHJCuNmiW--
</code></pre>
<h5 id="721-配置multipart解析器">7.2.1 配置multipart解析器</h5>
<ol>
<li>
<p>从 Spring 3.1 开 始，Spring 内置了两个 MultipartResolver 的实现供我们选择：</p>
<ul>
<li>
<p>CommonsMultipartResolver：使用 Jakarta Commons FileUpload 解析 multipart 请求；</p>
</li>
<li>
<p>StandardServletMultipartResolver：依赖于 Servlet 3.0 对 multipart 请求的支持（始于 Spring 3.1）。(常选)</p>
</li>
</ul>
</li>
<li>
<p>multipart的配置需要放到DispatcherServlet配置的一部分。</p>
</li>
</ol>
<h5 id="722-处理multipart请求">7.2.2 处理multipart请求</h5>
<ol>
<li>最常见的方式就是在某个控制器方法参数上添加 @RequestPart 注解。</li>
</ol>
<h4 id="73-处理异常">7.3 处理异常</h4>
<p>Spring 提供了多种方式将异常转换为响应：</p>
<ul>
<li>特定的 Spring 异常将会自动映射为指定的 HTTP 状态码；</li>
<li>异常上可以添加 @ResponseStatus 注解，从而将其映射为某一个 HTTP 状态码；</li>
<li>在方法上可以添加 @ExceptionHandler 注解，使其用来处理异常。</li>
</ul>
<h5 id="731-将异常映射为http状态码">7.3.1 将异常映射为HTTP状态码</h5>
<ol>
<li>在默认情况下，Spring 会将自身的一些异常自动转换为合适的状态码。表 7.1 列出了这些映射关系。</li>
</ol>
<table>
<thead>
<tr>
<th>Spring 异常</th>
<th>HTTP 状态码</th>
</tr>
</thead>
<tbody>
<tr>
<td>BindException</td>
<td>400 - Bad Request</td>
</tr>
<tr>
<td>ConversionNotSupportedException</td>
<td>500 - Internal Server Error</td>
</tr>
<tr>
<td>HttpMediaTypeNotAcceptableException</td>
<td>406 - Not Acceptable</td>
</tr>
<tr>
<td>HttpMediaTypeNotSupportedException</td>
<td>415 - Unsupported Media Type</td>
</tr>
<tr>
<td>HttpMessageNotReadableException</td>
<td>400 - Bad Request</td>
</tr>
<tr>
<td>HttpMessageNotWritableException</td>
<td>500 - Internal Server Error</td>
</tr>
<tr>
<td>HttpRequestMethodNotSupportedException</td>
<td>405 - Method Not Allowed</td>
</tr>
<tr>
<td>MethodArgumentNotValidException</td>
<td>400 - Bad Request</td>
</tr>
<tr>
<td>MissingServletRequestParameterException</td>
<td>400 - Bad Request</td>
</tr>
<tr>
<td>MissingServletRequestPartException</td>
<td>400 - Bad Request</td>
</tr>
<tr>
<td>NoSuchRequestHandlingMethodException</td>
<td>404 - Not Found</td>
</tr>
<tr>
<td>TypeMismatchException</td>
<td>400 - Bad Request</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>
<p>Spring可以通过@ResponseStatus注解将异常映射为HTTP状态码。例子：</p>
<pre><code class="language-java">@RequestMapping(value=&quot;/{spittleId}&quot;, method=RequestMethod.GET)
public String spittle(
	@Pathvariable(&quot;spittleId&quot;) long spittleId,
    Model model) {
    Spittle spittle = spittleRepository.findOne(spittleId);
    if (spittle == null) {
        throw new SpittleNotFoundException();
    }
    model.addAttribute(spittle);
    return &quot;spittle&quot;;
}
</code></pre>
<p>当findOne找不到spittle为空时，抛出自定义异常SpittleNotFoundException，默认会产生500状态码，但是对于资源没找到，比较精确的描述应该是是404，所以可以自定义映射SpittleNotFoundException来进行变更：</p>
<pre><code class="language-java">package spittr.web;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=&quot;Spittle Not Found&quot;)
public class SpittleNotFoundException extends RuntimeException {
}
</code></pre>
</li>
</ol>
<h5 id="732-编写异常处理的方法">7.3.2 编写异常处理的方法</h5>
<ol>
<li>
<p>前文已经对于错误可以成功映射了，但是有时我们还想在exception中包含产生的错误，我们此时需要将异常视为请求来处理。</p>
</li>
<li>
<p>例子：当用户提交的spittle和已创建的文本一模一样，则save()方法会抛出DuplicateSpittle Exception，那么SpittleController的saveSpittle就要处理这个异常。基本操作：</p>
<pre><code class="language-java">@RequestMapping(method=RequestMethod.POST)
public String saveSpittle(SpittleForm form, Model model) {
  try {
    spittleRepository.save(new Spittle(null, form.getMessage(), new Date(), 
        form.getLongitude(), form.getLatitude()));
    return &quot;redirect:/spittles&quot;;
  } catch (DuplicateSpittleException e) {
    return &quot;error/duplicate&quot;;
  }
}
</code></pre>
<p>基本操作稍微复杂。可以改为如下设计：</p>
<ol>
<li>
<p>首先剥离异常处理</p>
<pre><code class="language-java">@RequestMapping(method=RequestMethod.POST)
public String saveSpittle(SpittleForm form, Model model) {
  spittleRepository.save(new Spittle(null, form.getMessage(), new Date(), 
    form.getLongitude(), form.getLatitude()));
  return &quot;redirect:/spittles&quot;;
}
</code></pre>
</li>
<li>
<p>为异常处理增加一个方法在controller，handleDuplicateSpittle() 方法上添加了 @ExceptionHandler 注解，当抛出  DuplicateSpittleException 异常的时候，将会委托该方法来处理</p>
<pre><code class="language-java">@ExceptionHandler(DuplicateSpittleException.class)
public String handleDuplicateSpittle() {
  return &quot;error/duplicate&quot;;
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>这个异常处理可以处理整个controller的DuplicateSpittleException。</p>
</li>
</ol>
<h4 id="74-为控制器添加通知">7.4 为控制器添加通知</h4>
<ol>
<li>
<p>如果有handler可以处理整个项目相同类型而不是局限于一个controller就好了。</p>
</li>
<li>
<p><strong><u>控制器通知（controller advice）是任意带有 @ControllerAdvice 注解的类</u></strong>，这个类会包含一个或多个如下类型的方法：</p>
<ul>
<li>@ExceptionHandler 注解标注的方法；</li>
<li>@InitBinder 注解标注的方法；</li>
<li>@ModelAttribute 注解标注的方法。</li>
</ul>
</li>
<li>
<p>最为实用的一个场景就是将所有的 @ExceptionHandler 方法收集到一个类中，这样所有控制器的异常就能在一个地方进行一致的处理。例如：</p>
<pre><code class="language-java">package spittr.web;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class AppWideExceptionHandler {

  @ExceptionHandler(DuplicateSpittleException.class)
  public String handleNotFound() {
    return &quot;error/duplicate&quot;;
  }

}
</code></pre>
</li>
</ol>
<h4 id="75-跨重定向请求传递数据">7.5 跨重定向请求传递数据</h4>
<p>model数据以请求参数形式复制到请求中，重定向会丢失。</p>
<h6 id="751-通过url模板进行重定向">7.5.1 通过URL模板进行重定向</h6>
<ol>
<li>
<p>当构建 URL 或 SQL 查询语句的时候，使用 String 连接是很危险的-&gt; 注入。</p>
</li>
<li>
<p>除了连接String的方式来构建重定向URL，Spring还提供了使用模板的方式来定义重定向URL。</p>
</li>
<li>
<p>使用模板的方式可以避免安全问题，因为不安全字符都会被转义。</p>
<pre><code class="language-java">@RequestMapping(value=&quot;/register&quot;, method=POST)
public String processRegistration(
    Spitter spitter, Model model) {
  spitterRepository.save(spitter);
  model.addAttribute(&quot;username&quot;, spitter.getUsername());
  model.addAttribute(&quot;spitterId&quot;, spitter.getId());
  return &quot;redirect:/spitter/{username}&quot;;
}
</code></pre>
</li>
<li>
<p>但是他的限制就是只能用来发送相对简单的值。</p>
</li>
</ol>
<h5 id="752-使用flash属性">7.5.2 使用flash属性</h5>
<ol>
<li>
<p>假设我们要发一个Spitter对象。</p>
</li>
<li>
<p>将Spitter model放在session中用以重定向之后的使用，但是要在使用后清除掉。</p>
</li>
<li>
<p>Spring认为我们不需要管理这些数据，提供了flash属性。flash会一直携带这些数据直到下一次请求，然后才会消失。</p>
</li>
<li>
<p>Spring 提供了通过 RedirectAttributes 设置 flash 属性的方法，这是 Spring 3.1 引入的 Model 的一个子接口。RedirectAttributes 提供了 Model 的所有功能。 具体来讲，RedirectAttributes 提供了一组addFlashAttribute() 方法来添加 flash 属性。</p>
<pre><code class="language-java">@RequestMapping(value=&quot;/register&quot;, method=POST)
public String processRegistration(
    Spitter spitter, RedirectAttribute model) {
  spitterRespository.save(spitter);
  model.addAttribute(&quot;username&quot;, spitter.getUsername());
  model.addFlashAttribute(&quot;spitter&quot;, spitter); // 甚至可以不指定key参数，让它根据类型自行推断。
  return &quot;redirect:/spitter/{username}&quot;;
}
</code></pre>
<p>原理还是利用session：</p>
 <img src="https://702021806-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LmcjU5gG__lBrRbUxBO%2F-LnG0D9ekEJgNHLYjo_U%2F-LnG1lKFbORLQXOP5PK9%2F7.2%20flash%E5%B1%9E%E6%80%A7.jpg?alt=media&token=7ca906a5-8a1f-4eb6-ad76-1806559066c2" alt="img" style="zoom:50%;" />
</li>
<li>
<p>使用（下游消费Spitter），在数据库查询之前，先看会话是否带有Spitter对象</p>
<pre><code class="language-java">@RequestMapping(value=&quot;/{username}&quot;, method=GET)
public String showSpitterProfile(
    @PathVariable String username, Model model) {
  if (!model.containsAttribute(&quot;spitter&quot;)) {
    model.addAttribute(spitterRepository.findByUsername(username));
  }
  return &quot;profile&quot;;
}
</code></pre>
</li>
</ol>
<h4 id="76-小结">7.6 小结</h4>
<h3 id="第八章-使用spring-web-flow">第八章 使用Spring Web Flow</h3>
<p>略</p>
<h3 id="第九章-保护web应用">第九章 保护Web应用</h3>
<ul>
<li>Spring Sesecurity介绍</li>
<li>使用Servlet规范中的Filter保护Web应用</li>
<li>基于数据库和LDAP进行认证</li>
</ul>
<p>Spring Security是基于Spring AOP的Servlet规范中的Filter实现的安全框架。</p>
<h4 id="91-spring-security简介">9.1 Spring Security简介</h4>
<ol>
<li>在Web请求级别和方法调用级别处理身份认证和授权</li>
<li>基于Spring，充分利用DI和AOP</li>
</ol>
<h5 id="911-理解spring-security的模块">9.1.1 理解Spring Security的模块</h5>
<table>
<thead>
<tr>
<th>模块</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACL</td>
<td>支持通过访问控制列表为域对象提供安全性</td>
</tr>
<tr>
<td>切面</td>
<td>当使用Spring Security注解时，会使用基于AspectJ的切面而不是标准的SpringAOP</td>
</tr>
<tr>
<td>CAS客户端</td>
<td>提供与Jasig的中心认证服务进行集成的功能</td>
</tr>
<tr>
<td>配置</td>
<td>包含通过XML和Java配置SPring Security的功能支持核心提供Spring Security基本库</td>
</tr>
<tr>
<td>加密</td>
<td>提供了加密和密码编码的功能</td>
</tr>
<tr>
<td>LDAP</td>
<td>支持基于LDAP进行认证</td>
</tr>
<tr>
<td>OpenID</td>
<td>支持基于LDAP进行认证</td>
</tr>
<tr>
<td>Remoting</td>
<td>提供了对Spring Remoting的支持</td>
</tr>
<tr>
<td>标签库</td>
<td>Spring Security 的 JSP 标签库</td>
</tr>
<tr>
<td>Web</td>
<td>提供了 Spring Security 基于 Filter 的 Web 安全性支持</td>
</tr>
</tbody>
</table>
<h5 id="912-过滤web请求">9.1.2 过滤Web请求</h5>
<ol>
<li>只需要配置一个Filter，DelegatingFilterProxy 是一个特殊的 Servlet Filter，它本身所做的工作并不多。只是将工作委托给一个 javax.servlet.Filter 实现类，这个实现类作为一个注册在 Spring 应用的上下文中。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://702021806-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LmcjU5gG__lBrRbUxBO%2F-LnGu6bgwiA2GnSvlRls%2F-LnGuRaW94jd-DldRJ-N%2F9.1%20filter%20bean.jpg?alt=media&amp;token=cfb4c28d-7682-4b77-b979-6098da69bf37" alt="img" loading="lazy"></figure>
<ol start="2">
<li>可以通过Java或者xml配置这个filter。他会拦截发往应用中请求，并将请求委托给ID为springSecurityFilterChain bean。</li>
<li>springSecurityFilterChain也称作FilterChainProxy，他可以链接任一或多个其他的filter。你不需要显式声明这些，它会自动创建。</li>
</ol>
<h5 id="913-编写简单的安全性配置">9.1.3 编写简单的安全性配置</h5>
<ol>
<li>
<p>@EnableWebSecurity 注解将会启用 Web 安全功能。任何实现了WebSecurityConfigurer的bean都可以用来配置Spring Security。</p>
</li>
<li>
<p>但是当你是Spring MVC开发者的时候，你还可以选择@EnableWebMvcSecurity</p>
<pre><code class="language-java">package spitter.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.servlet.configuration.EnableWebMvcSecurity;

@Configuration
@EnableWebMvcSecurity
// @EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
}
</code></pre>
</li>
<li>
<p>通过重载WebSecurityConfigurerAdapter的configure方法配置。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>configure(WebSecurity)</td>
<td>通过重载配置SpringSecurity的Filter 链</td>
</tr>
<tr>
<td>configure(HttpSecurity)</td>
<td>通过重载，配置如何通过拦截器保护请求</td>
</tr>
<tr>
<td>configure(AuthenticationManagerBuilder)</td>
<td>通过重载，配置userdetail服务</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="92-选择查询用户详细信息的服务">9.2 选择查询用户详细信息的服务</h4>
<h5 id="921-使用基于内存的用户存储">9.2.1 使用基于内存的用户存储</h5>
<ol>
<li>
<p>通过 inMemoryAuthentication() 方法，我们可以启用、配置并任意填充基于内存的用户存储。</p>
<pre><code class="language-java">package spittr.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.servlet.configuration.EnableWebMvcSecurity;


@Configuration
@EnableWebMvcSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .inMemoryAuthentication()
            .withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;);
    }
}
</code></pre>
</li>
<li>
<p>roles方法是authorities方法的简写,roles方法所给定的值都会添加一个”ROLE_&quot;前缀。</p>
<pre><code class="language-java">auth
  .inMemoryAuthentication()
  .withUser(&quot;user&quot;).password(&quot;password&quot;).authorities(&quot;ROLE_USER&quot;)
  .and()
  .withUser(&quot;admin&quot;).password(&quot;password&quot;).authorities(&quot;ROLE_USER&quot;, &quot;ROLE_ADMIN&quot;);
</code></pre>
</li>
<li>
<p>方法列表</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>accountExpired(boolean)</td>
<td>定义账号是否已过期</td>
</tr>
<tr>
<td>accountLocked(boolean)</td>
<td>定义账号是否已锁定</td>
</tr>
<tr>
<td>and()</td>
<td>用来连接配置</td>
</tr>
<tr>
<td>authorities(GrantedAuthority...)</td>
<td>授予某个用户一项或多项权限</td>
</tr>
<tr>
<td>authorities(List&lt;?&lt;GrantedAuthority&gt;)</td>
<td>授予某个用户一项或多项权限</td>
</tr>
<tr>
<td>authorities(String...)</td>
<td>授予某个用户一项或多项权限</td>
</tr>
<tr>
<td>credentialsExprired(boolean)</td>
<td>定义凭证是否已经过期</td>
</tr>
<tr>
<td>disabled(boolean)</td>
<td>定义账号是否已被禁用</td>
</tr>
<tr>
<td>password(String)</td>
<td>用户定义的密码</td>
</tr>
<tr>
<td>roles(String)</td>
<td>授予某个用户一项或多项角色</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>基于内存的方式对于开发测试友好，但是不适合生产环境。生产环境的用户数据比较适合保存在数据库中，</p>
</li>
</ol>
<h5 id="922-基于数据表进行认证">9.2.2 基于数据表进行认证</h5>
<ol>
<li>
<p>为了配置Spring Security使用JDBC为支持的用户存储，可以使用jdbc-Authentication()方法。</p>
<pre><code class="language-java">@Autowired
DataSource dataSource;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth
    .jdbcAuthentication()
    .dataSource(dataSource);
}
</code></pre>
</li>
<li>
<p>Spring内部实现了默认的用户表查询，但是当你的数据库用户表不是默认实现的那些表名和列，侧需要自己额外配置：</p>
<pre><code class="language-java">@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthtication()
        .dataSource(dataSource)
        .usersByUsernameQuery(
    		&quot;select username, password, true from Spitter where username=?&quot;)
        .authoritiesByUsernameUuery(
    		&quot;select username, 'ROLE_USER' from Spitter where username=?&quot;);
}
</code></pre>
</li>
<li>
<p>将默认的SQL查询替换为自定义设计时，要遵循查询的及本协议：</p>
<ol>
<li>所有查询用户名作为唯一的查询参数</li>
<li>认证查询会选取用户名、密码以及启用状态信息。</li>
</ol>
</li>
<li>
<p>数据库不要使用明文存储，所以在存储之前，要对密码做一步转码处理，将转码后的数据存入数据库，当认证的时候用同样的流程转码，然后对比数据库中的存储。</p>
<pre><code class="language-java">@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth
    .jdbcAuthentication()
    .dataSource(dataSource)
    .usersByUsernameQuery(
      &quot;select username, password, true &quot; +
      &quot;from Spitter where username=?&quot;)
    .authoritiesByUsernameQuery(
      &quot;select username, 'ROLE_USER' from Spitter where username=?&quot;)
    .passwordEncoder(new StandardPasswordEnconder(&quot;123456&quot;));
}
</code></pre>
</li>
<li>
<p>passworkEncoder方法可以接受PasswordEncoder接口的任意实现（BCryptPasswordEncoder、NoOpPasswordEncoder 和  StandardPasswordEncoder），当默认的三种不能满足时，你还可以自定义实现。</p>
<pre><code class="language-java">public interface PasswordEncoder {
    String encode(CharSequence rawPassword);
    boolean matched(CharSequence rawPassword, String encodePassword);
}
</code></pre>
</li>
</ol>
<h5 id="923-基于ldap进行认证">9.2.3 基于LDAP进行认证</h5>
<p>略</p>
<h5 id="924-配置自定义的用户服务">9.2.4 配置自定义的用户服务</h5>
<p>略</p>
<h4 id="93-拦截请求">9.3 拦截请求</h4>
<h5 id="931-使用spring表达式进行安全保护">9.3.1 使用SPring表达式进行安全保护</h5>
<table>
<thead>
<tr>
<th>安全表达式</th>
<th>计算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>authentication</td>
<td>用户的认证对象</td>
</tr>
<tr>
<td>denyAll</td>
<td>结果始终为false</td>
</tr>
<tr>
<td>hasAnyRole(list of roles)</td>
<td>如果用户被授予了列表中任意角色，返回true</td>
</tr>
<tr>
<td>hasRole(role)</td>
<td>如果用户被授予指定角色，返回true</td>
</tr>
<tr>
<td>hasIpAddress(IP Address)</td>
<td>如果用户来自指定IP，返回true</td>
</tr>
<tr>
<td>isAnonymous()</td>
<td>如果当前用户为匿名用户，结果为true</td>
</tr>
<tr>
<td>isAuthenticated()</td>
<td>如果当前用户进行了认证的话，结果为true</td>
</tr>
<tr>
<td>isFullyAuthenticated()</td>
<td>如果当前用户进行了认证的话（不是用过Remember-me功能进行的认证），结果为true</td>
</tr>
<tr>
<td>isRemeberMe()</td>
<td>如果当前用户是通过 Remember-me 自动认证的，结果为 true</td>
</tr>
<tr>
<td>permitAll</td>
<td>结果始终为true</td>
</tr>
<tr>
<td>principal</td>
<td>用户的principal对象</td>
</tr>
</tbody>
</table>
<h5 id="932-强制通道的安全性">9.3.2 强制通道的安全性</h5>
<ol>
<li>
<p>传递到 configure() 方法中的 HttpSecurity 对象有一个 requiresChannel() 方法，借助这个方法能够为各种 URL 模式声明所要求的通道</p>
<pre><code class="language-java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .authorizeRequests()
    .antMatchers(&quot;/spitter/me&quot;).hasRole(&quot;SPITTER&quot;)
    .antMatchers(HttpMethod.POST, &quot;/spittles&quot;).hasRole(&quot;SPITTER&quot;)
    .anyRequest().permitAll()
    .and()
    .requeresChannel()
    .antMatchers(&quot;/spitter/form&quot;).requiresSecure();
}
</code></pre>
</li>
<li>
<p>有些页面（e.g. 首页）不需要HTTPS传送，可以使用requiresSecure()方法，生命为始终通过HTTP传送：</p>
<pre><code class="language-java">.antMatchers(&quot;/&quot;).requiresInecure();
// regexMathcers()
</code></pre>
</li>
</ol>
<h5 id="933-防止跨站请求伪造">9.3.3 防止跨站请求伪造</h5>
<ol>
<li>Spring Security 3.2开始就默认启动SCRF防护了。</li>
</ol>
<h4 id="94-认证用户">9.4 认证用户</h4>
<h5 id="941-添加自定义的登录页">9.4.1 添加自定义的登录页</h5>
<h5 id="942-启动http-basic认证">9.4.2 启动HTTP Basic认证</h5>
<ol>
<li>
<p>HTTP Basic 认证（HTTP Basic Authentication）会直接通过 HTTP 请求本身，对要访问应用程序的用户进行认证。你可能在以前见过 HTTP Basic 认证。当在 Web 浏览器中使用时，它将向用户弹出一个简单的模态对话框。</p>
<pre><code class="language-java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .formLogin()
    .loginPage(&quot;/login&quot;);
    .and()
    .httpBasic()
    .realmName(&quot;Spittr&quot;)
    .and()
    ...
}
</code></pre>
</li>
</ol>
<h5 id="943-启动remember-me功能">9.4.3 启动Remember-me功能</h5>
<ol>
<li>默认情况下，这个功能是通过在 cookie 中存储一个 token 完成的，这个 token 最多两周内有效。我们也可以指定validation的时间。</li>
</ol>
<h5 id="944-退出">9.4.4 退出</h5>
<ol>
<li>退出功能是通过 Servlet 容器中的Filter实现的（默认情况下），这个 Filter 会拦截针对 “/logout” 的请求。</li>
<li>当用户点击这个链接的时候，会发起对 “/logout” 的请求，这个请求会被 Spring Security 的 LogoutFilter 所处理。用户会退出应用，所有的 Remember-me token 都会被清除掉。在退出完成后，用户浏览器将会 重定向到 “/login?logout”，从而允许用户进行再次登录。 如果你希望用户被重定向到其他的页面，如应用的首页，那么可以在 configure() 中进行配置。</li>
</ol>
<h4 id="95-保护视图">9.5 保护视图</h4>
<p>Spring Security 本身提供了一个 JSP 标签库，而 Thymeleaf 通过特定的方言实现了与 Spring Security 的集成。</p>
<h4 id="96-小结">9.6 小结</h4>
<p>在前面的几章中，我们看到了如何将 Spring 运用到应用程序的前端，后面会介绍Spring如何在后端发挥作用。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-web%E4%B8%AD%E7%9A%84spring">第二部分 Web中的Spring</a>
<ul>
<li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E5%BB%BAspring-web-application">第五章 构建Spring Web Application</a>
<ul>
<li><a href="#51-spring-mvc%E8%B5%B7%E6%AD%A5">5.1 Spring MVC起步</a>
<ul>
<li><a href="#511-%E8%B7%9F%E8%B8%AAspring-mvc%E7%9A%84%E8%AF%B7%E6%B1%82">5.1.1 跟踪Spring MVC的请求</a></li>
<li><a href="#512-%E6%90%AD%E5%BB%BAspring-mvc">5.1.2 搭建Spring MVC</a></li>
<li><a href="#513-spittr%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B">5.1.3 Spittr应用简介</a></li>
</ul>
</li>
<li><a href="#52-%E7%BC%96%E5%86%99%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8">5.2 编写基本的控制器</a>
<ul>
<li><a href="#521-%E6%B5%8B%E8%AF%95%E6%8E%A7%E5%88%B6%E5%99%A8">5.2.1 测试控制器</a></li>
<li><a href="#522-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86">5.2.2 定义类级别的请求处理</a></li>
<li><a href="#523-%E4%BC%A0%E9%80%92%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%88%B0%E8%A7%86%E5%9B%BE%E4%B8%AD">5.2.3 传递模型数据到视图中</a></li>
</ul>
</li>
<li><a href="#53-%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BE%93%E5%85%A5">5.3 接收请求的输入</a>
<ul>
<li><a href="#531-%E5%A4%84%E7%90%86%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0">5.3.1 处理查询参数</a></li>
<li><a href="#532-%E9%80%9A%E8%BF%87%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%8E%A5%E5%8F%97%E8%BE%93%E5%85%A5">5.3.2 通过路径参数接受输入</a></li>
</ul>
</li>
<li><a href="#54-%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95">5.4 处理表单</a>
<ul>
<li><a href="#541-%E7%BC%96%E5%86%99%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8">5.4.1 编写处理表单的控制器</a></li>
<li><a href="#542-%E6%A0%A1%E9%AA%8C%E8%A1%A8%E5%8D%95">5.4.2 校验表单</a></li>
</ul>
</li>
<li><a href="#55-%E5%B0%8F%E7%BB%93">5.5 小结</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B8%B2%E6%9F%93web%E8%A7%86%E5%9B%BE">第六章 渲染Web视图</a>
<ul>
<li><a href="#61-%E7%90%86%E8%A7%A3%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90">6.1 理解视图解析</a></li>
<li><a href="#62-%E5%88%9B%E5%BB%BAjsp%E8%A7%86%E5%9B%BE">6.2 创建JSP视图</a>
<ul>
<li><a href="#621-%E9%85%8D%E7%BD%AE%E9%80%82%E7%94%A8%E4%BA%8Ejsp%E7%9A%84%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90">6.2.1 配置适用于JSP的视图解析</a></li>
<li><a href="#622-%E4%BD%BF%E7%94%A8spring%E7%9A%84jsp%E5%BA%93">6.2.2 使用Spring的JSP库</a></li>
</ul>
</li>
<li><a href="#63-%E4%BD%BF%E7%94%A8apache-tiles%E8%A7%86%E5%9B%BE%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80">6.3 使用Apache Tiles视图定义布局</a>
<ul>
<li><a href="#631-%E9%85%8D%E7%BD%AEtiles%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8">6.3.1 配置Tiles视图解析器</a></li>
</ul>
</li>
<li><a href="#64-%E4%BD%BF%E7%94%A8thymeleaf">6.4 使用Thymeleaf</a>
<ul>
<li><a href="#641-%E9%85%8D%E7%BD%AEthymeleaf%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8">6.4.1 配置Thymeleaf视图解析器</a></li>
<li><a href="#642-%E5%AE%9A%E4%B9%89thymeleaf%E6%A8%A1%E6%9D%BF">6.4.2 定义Thymeleaf模板</a></li>
</ul>
</li>
<li><a href="#65-%E5%B0%8F%E7%BB%93">6.5 小结</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-spring-mvc-%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF">第七章 Spring MVC 高级技术</a>
<ul>
<li><a href="#71-spring-mvc%E9%85%8D%E7%BD%AE%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88">7.1 Spring MVC配置的替代方案</a>
<ul>
<li><a href="#711-%E8%87%AA%E5%AE%9A%E4%B9%89dispatcherservlet%E9%85%8D%E7%BD%AE">7.1.1 自定义DispatcherServlet配置</a></li>
<li><a href="#712-%E6%B7%BB%E5%8A%A0%E5%85%B6%E4%BB%96%E7%9A%84servlet%E5%92%8Cfilter">7.1.2 添加其他的Servlet和Filter</a></li>
<li><a href="#713-%E5%9C%A8webxml%E4%B8%AD%E5%A3%B0%E6%98%8Edispatcherservlet">7.1.3 在web.xml中声明DispatcherServlet</a></li>
</ul>
</li>
<li><a href="#72-%E5%A4%84%E7%90%86multipart%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE">7.2 处理multipart形式的数据</a>
<ul>
<li><a href="#721-%E9%85%8D%E7%BD%AEmultipart%E8%A7%A3%E6%9E%90%E5%99%A8">7.2.1 配置multipart解析器</a></li>
<li><a href="#722-%E5%A4%84%E7%90%86multipart%E8%AF%B7%E6%B1%82">7.2.2 处理multipart请求</a></li>
</ul>
</li>
<li><a href="#73-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">7.3 处理异常</a>
<ul>
<li><a href="#731-%E5%B0%86%E5%BC%82%E5%B8%B8%E6%98%A0%E5%B0%84%E4%B8%BAhttp%E7%8A%B6%E6%80%81%E7%A0%81">7.3.1 将异常映射为HTTP状态码</a></li>
<li><a href="#732-%E7%BC%96%E5%86%99%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95">7.3.2 编写异常处理的方法</a></li>
</ul>
</li>
<li><a href="#74-%E4%B8%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%9F%A5">7.4 为控制器添加通知</a></li>
<li><a href="#75-%E8%B7%A8%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%B7%E6%B1%82%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE">7.5 跨重定向请求传递数据</a><br>
*
<ul>
<li><a href="#751-%E9%80%9A%E8%BF%87url%E6%A8%A1%E6%9D%BF%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%AE%9A%E5%90%91">7.5.1 通过URL模板进行重定向</a></li>
<li><a href="#752-%E4%BD%BF%E7%94%A8flash%E5%B1%9E%E6%80%A7">7.5.2 使用flash属性</a></li>
</ul>
</li>
<li><a href="#76-%E5%B0%8F%E7%BB%93">7.6 小结</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E4%BD%BF%E7%94%A8spring-web-flow">第八章 使用Spring Web Flow</a></li>
<li><a href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E4%BF%9D%E6%8A%A4web%E5%BA%94%E7%94%A8">第九章 保护Web应用</a>
<ul>
<li><a href="#91-spring-security%E7%AE%80%E4%BB%8B">9.1 Spring Security简介</a>
<ul>
<li><a href="#911-%E7%90%86%E8%A7%A3spring-security%E7%9A%84%E6%A8%A1%E5%9D%97">9.1.1 理解Spring Security的模块</a></li>
<li><a href="#912-%E8%BF%87%E6%BB%A4web%E8%AF%B7%E6%B1%82">9.1.2 过滤Web请求</a></li>
<li><a href="#913-%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%85%8D%E7%BD%AE">9.1.3 编写简单的安全性配置</a></li>
</ul>
</li>
<li><a href="#92-%E9%80%89%E6%8B%A9%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E7%9A%84%E6%9C%8D%E5%8A%A1">9.2 选择查询用户详细信息的服务</a>
<ul>
<li><a href="#921-%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E7%94%A8%E6%88%B7%E5%AD%98%E5%82%A8">9.2.1 使用基于内存的用户存储</a></li>
<li><a href="#922-%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E8%AE%A4%E8%AF%81">9.2.2 基于数据表进行认证</a></li>
<li><a href="#923-%E5%9F%BA%E4%BA%8Eldap%E8%BF%9B%E8%A1%8C%E8%AE%A4%E8%AF%81">9.2.3 基于LDAP进行认证</a></li>
<li><a href="#924-%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%94%A8%E6%88%B7%E6%9C%8D%E5%8A%A1">9.2.4 配置自定义的用户服务</a></li>
</ul>
</li>
<li><a href="#93-%E6%8B%A6%E6%88%AA%E8%AF%B7%E6%B1%82">9.3 拦截请求</a>
<ul>
<li><a href="#931-%E4%BD%BF%E7%94%A8spring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4">9.3.1 使用SPring表达式进行安全保护</a></li>
<li><a href="#932-%E5%BC%BA%E5%88%B6%E9%80%9A%E9%81%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7">9.3.2 强制通道的安全性</a></li>
<li><a href="#933-%E9%98%B2%E6%AD%A2%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">9.3.3 防止跨站请求伪造</a></li>
</ul>
</li>
<li><a href="#94-%E8%AE%A4%E8%AF%81%E7%94%A8%E6%88%B7">9.4 认证用户</a>
<ul>
<li><a href="#941-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5">9.4.1 添加自定义的登录页</a></li>
<li><a href="#942-%E5%90%AF%E5%8A%A8http-basic%E8%AE%A4%E8%AF%81">9.4.2 启动HTTP Basic认证</a></li>
<li><a href="#943-%E5%90%AF%E5%8A%A8remember-me%E5%8A%9F%E8%83%BD">9.4.3 启动Remember-me功能</a></li>
<li><a href="#944-%E9%80%80%E5%87%BA">9.4.4 退出</a></li>
</ul>
</li>
<li><a href="#95-%E4%BF%9D%E6%8A%A4%E8%A7%86%E5%9B%BE">9.5 保护视图</a></li>
<li><a href="#96-%E5%B0%8F%E7%BB%93">9.6 小结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://10kshuaizhang.github.io/post/Spring实战（第四版）笔记-Part1（依赖注入和切面编程基础概念）/">
              <h3 class="post-title">
                Spring实战(第四版)- part1(基础部分)
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '3f6a89270d2a0e51772d',
    clientSecret: '58f2d7ec868483233a31553fa6235f2efd1df763',
    repo: '10kshuaizhang.github.io',
    owner: '10kshuaizhang',
    admin: ['10kshuaizhang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  
  <a class="rss" href="https://10kshuaizhang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
